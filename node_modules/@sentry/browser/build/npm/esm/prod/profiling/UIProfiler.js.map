{"version":3,"file":"UIProfiler.js","sources":["../../../../../src/profiling/UIProfiler.ts"],"sourcesContent":["import type { Client, ContinuousProfiler, ProfileChunk, ProfileChunkEnvelope, Span } from '@sentry/core';\nimport {\n  createEnvelope,\n  debug,\n  dsnToString,\n  getGlobalScope,\n  getRootSpan,\n  getSdkMetadataForEnvelopeHeader,\n  uuid4,\n} from '@sentry/core';\nimport type { BrowserOptions } from '../client';\nimport { DEBUG_BUILD } from './../debug-build';\nimport type { JSSelfProfiler } from './jsSelfProfiling';\nimport { createProfileChunkPayload, shouldProfileSession, startJSSelfProfile, validateProfileChunk } from './utils';\n\nconst CHUNK_INTERVAL_MS = 60_000; // 1 minute\n// Maximum length for trace lifecycle profiling per root span (e.g. if spanEnd never fires)\nconst MAX_ROOT_SPAN_PROFILE_MS = 300_000; // 5 minutes max per root span in trace mode\n\n/**\n * UIProfiler (Profiling V2):\n * Supports two lifecycle modes:\n *  - 'manual': controlled explicitly via start()/stop()\n *  - 'trace': automatically runs while there are active sampled root spans\n *\n * Profiles are emitted as standalone `profile_chunk` envelopes either when:\n * - there are no more sampled root spans, or\n * - the 60s chunk timer elapses while profiling is running.\n */\nexport class UIProfiler implements ContinuousProfiler<Client> {\n  private _client: Client | undefined;\n  private _profiler: JSSelfProfiler | undefined;\n  private _chunkTimer: ReturnType<typeof setTimeout> | undefined;\n\n  // Manual + Trace\n  private _profilerId: string | undefined; // one per Profiler session\n  private _isRunning: boolean; // current profiler instance active flag\n  private _sessionSampled: boolean; // sampling decision for entire session\n  private _lifecycleMode: 'manual' | 'trace' | undefined;\n\n  // Trace-only\n  private _activeRootSpanIds: Set<string>;\n  private _rootSpanTimeouts: Map<string, ReturnType<typeof setTimeout>>;\n\n  public constructor() {\n    this._client = undefined;\n    this._profiler = undefined;\n    this._chunkTimer = undefined;\n\n    this._profilerId = undefined;\n    this._isRunning = false;\n    this._sessionSampled = false;\n    this._lifecycleMode = undefined;\n\n    this._activeRootSpanIds = new Set();\n    this._rootSpanTimeouts = new Map();\n  }\n\n  /**\n   * Initialize the profiler with client, session sampling and lifecycle mode.\n   */\n  public initialize(client: Client): void {\n    const lifecycleMode = (client.getOptions() as BrowserOptions).profileLifecycle;\n    const sessionSampled = shouldProfileSession(client.getOptions());\n\n    DEBUG_BUILD && debug.log(`[Profiling] Initializing profiler (lifecycle='${lifecycleMode}').`);\n\n    if (!sessionSampled) {\n      DEBUG_BUILD && debug.log('[Profiling] Session not sampled. Skipping lifecycle profiler initialization.');\n    }\n\n    // One Profiler ID per profiling session (user session)\n    this._profilerId = uuid4();\n    this._client = client;\n    this._sessionSampled = sessionSampled;\n    this._lifecycleMode = lifecycleMode;\n\n    if (lifecycleMode === 'trace') {\n      this._setupTraceLifecycleListeners(client);\n    }\n  }\n\n  /** Starts UI profiling (only effective in 'manual' mode and when sampled). */\n  public start(): void {\n    if (this._lifecycleMode === 'trace') {\n      DEBUG_BUILD &&\n        debug.warn(\n          '[Profiling] `profileLifecycle` is set to \"trace\". Calls to `uiProfiler.start()` are ignored in trace mode.',\n        );\n      return;\n    }\n\n    if (this._isRunning) {\n      DEBUG_BUILD && debug.warn('[Profiling] Profile session is already running, `uiProfiler.start()` is a no-op.');\n      return;\n    }\n\n    if (!this._sessionSampled) {\n      DEBUG_BUILD && debug.warn('[Profiling] Session is not sampled, `uiProfiler.start()` is a no-op.');\n      return;\n    }\n\n    this._beginProfiling();\n  }\n\n  /** Stops UI profiling (only effective in 'manual' mode). */\n  public stop(): void {\n    if (this._lifecycleMode === 'trace') {\n      DEBUG_BUILD &&\n        debug.warn(\n          '[Profiling] `profileLifecycle` is set to \"trace\". Calls to `uiProfiler.stop()` are ignored in trace mode.',\n        );\n      return;\n    }\n\n    if (!this._isRunning) {\n      DEBUG_BUILD && debug.warn('[Profiling] Profiler is not running, `uiProfiler.stop()` is a no-op.');\n      return;\n    }\n\n    this._endProfiling();\n  }\n\n  /** Handle an already-active root span at integration setup time (used only in trace mode). */\n  public notifyRootSpanActive(rootSpan: Span): void {\n    if (this._lifecycleMode !== 'trace' || !this._sessionSampled) {\n      return;\n    }\n\n    const spanId = rootSpan.spanContext().spanId;\n    if (!spanId || this._activeRootSpanIds.has(spanId)) {\n      return;\n    }\n\n    this._registerTraceRootSpan(spanId);\n\n    const rootSpanCount = this._activeRootSpanIds.size;\n\n    if (rootSpanCount === 1) {\n      DEBUG_BUILD &&\n        debug.log('[Profiling] Detected already active root span during setup. Active root spans now:', rootSpanCount);\n\n      this._beginProfiling();\n    }\n  }\n\n  /**\n   * Begin profiling if not already running.\n   */\n  private _beginProfiling(): void {\n    if (this._isRunning) {\n      return;\n    }\n    this._isRunning = true;\n\n    DEBUG_BUILD && debug.log('[Profiling] Started profiling with profiler ID:', this._profilerId);\n\n    // Expose profiler_id to match root spans with profiles\n    getGlobalScope().setContext('profile', { profiler_id: this._profilerId });\n\n    this._startProfilerInstance();\n\n    if (!this._profiler) {\n      DEBUG_BUILD && debug.log('[Profiling] Failed to start JS Profiler; stopping.');\n      this._resetProfilerInfo();\n      return;\n    }\n\n    this._startPeriodicChunking();\n  }\n\n  /** End profiling session; final chunk will be collected and sent. */\n  private _endProfiling(): void {\n    if (!this._isRunning) {\n      return;\n    }\n    this._isRunning = false;\n\n    if (this._chunkTimer) {\n      clearTimeout(this._chunkTimer);\n      this._chunkTimer = undefined;\n    }\n\n    this._clearAllRootSpanTimeouts();\n\n    // Collect whatever was currently recording\n    this._collectCurrentChunk().catch(e => {\n      DEBUG_BUILD && debug.error('[Profiling] Failed to collect current profile chunk on `stop()`:', e);\n    });\n\n    // Manual: Clear profiling context so spans outside start()/stop() aren't marked as profiled\n    // Trace: Profile context is kept for the whole session duration\n    if (this._lifecycleMode === 'manual') {\n      getGlobalScope().setContext('profile', {});\n    }\n  }\n\n  /** Trace-mode: attach spanStart/spanEnd listeners. */\n  private _setupTraceLifecycleListeners(client: Client): void {\n    client.on('spanStart', span => {\n      if (!this._sessionSampled) {\n        DEBUG_BUILD &&\n          debug.log('[Profiling] Span not profiled because of negative sampling decision for user session.');\n        return;\n      }\n      if (span !== getRootSpan(span)) {\n        return; // only care about root spans\n      }\n      // Only count sampled root spans\n      if (!span.isRecording()) {\n        DEBUG_BUILD && debug.log('[Profiling] Discarding profile because root span was not sampled.');\n        return;\n      }\n\n      const spanId = span.spanContext().spanId;\n      if (!spanId || this._activeRootSpanIds.has(spanId)) {\n        return;\n      }\n\n      this._registerTraceRootSpan(spanId);\n\n      const rootSpanCount = this._activeRootSpanIds.size;\n      if (rootSpanCount === 1) {\n        DEBUG_BUILD &&\n          debug.log(\n            `[Profiling] Root span ${spanId} started. Profiling active while there are active root spans (count=${rootSpanCount}).`,\n          );\n        this._beginProfiling();\n      }\n    });\n\n    client.on('spanEnd', span => {\n      if (!this._sessionSampled) {\n        return;\n      }\n      const spanId = span.spanContext().spanId;\n      if (!spanId || !this._activeRootSpanIds.has(spanId)) {\n        return;\n      }\n      this._activeRootSpanIds.delete(spanId);\n      const rootSpanCount = this._activeRootSpanIds.size;\n\n      DEBUG_BUILD &&\n        debug.log(\n          `[Profiling] Root span with ID ${spanId} ended. Will continue profiling for as long as there are active root spans (currently: ${rootSpanCount}).`,\n        );\n      if (rootSpanCount === 0) {\n        this._collectCurrentChunk().catch(e => {\n          DEBUG_BUILD && debug.error('[Profiling] Failed to collect current profile chunk on last `spanEnd`:', e);\n        });\n        this._endProfiling();\n      }\n    });\n  }\n\n  /**\n   * Resets profiling information from scope and resets running state (used on failure)\n   */\n  private _resetProfilerInfo(): void {\n    this._isRunning = false;\n    getGlobalScope().setContext('profile', {});\n  }\n\n  /**\n   * Clear and reset all per-root-span timeouts.\n   */\n  private _clearAllRootSpanTimeouts(): void {\n    this._rootSpanTimeouts.forEach(timeout => clearTimeout(timeout));\n    this._rootSpanTimeouts.clear();\n  }\n\n  /** Keep track of root spans and schedule safeguard timeout (trace mode). */\n  private _registerTraceRootSpan(spanId: string): void {\n    this._activeRootSpanIds.add(spanId);\n    const timeout = setTimeout(() => this._onRootSpanTimeout(spanId), MAX_ROOT_SPAN_PROFILE_MS);\n    this._rootSpanTimeouts.set(spanId, timeout);\n  }\n\n  /**\n   * Start a profiler instance if needed.\n   */\n  private _startProfilerInstance(): void {\n    if (this._profiler?.stopped === false) {\n      return; // already running\n    }\n    const profiler = startJSSelfProfile();\n    if (!profiler) {\n      DEBUG_BUILD && debug.log('[Profiling] Failed to start JS Profiler.');\n      return;\n    }\n    this._profiler = profiler;\n  }\n\n  /**\n   * Schedule the next 60s chunk while running.\n   * Each tick collects a chunk and restarts the profiler.\n   * A chunk should be closed when there are no active root spans anymore OR when the maximum chunk interval is reached.\n   */\n  private _startPeriodicChunking(): void {\n    if (!this._isRunning) {\n      return;\n    }\n\n    this._chunkTimer = setTimeout(() => {\n      this._collectCurrentChunk().catch(e => {\n        DEBUG_BUILD && debug.error('[Profiling] Failed to collect current profile chunk during periodic chunking:', e);\n      });\n\n      if (this._isRunning) {\n        this._startProfilerInstance();\n\n        if (!this._profiler) {\n          // If restart failed, stop scheduling further chunks and reset context.\n          this._resetProfilerInfo();\n          return;\n        }\n\n        this._startPeriodicChunking();\n      }\n    }, CHUNK_INTERVAL_MS);\n  }\n\n  /**\n   * Handle timeout for a specific root span ID to avoid indefinitely running profiler if `spanEnd` never fires.\n   * If this was the last active root span, collect the current chunk and stop profiling.\n   */\n  private _onRootSpanTimeout(rootSpanId: string): void {\n    // If span already ended, ignore\n    if (!this._rootSpanTimeouts.has(rootSpanId)) {\n      return;\n    }\n    this._rootSpanTimeouts.delete(rootSpanId);\n\n    if (!this._activeRootSpanIds.has(rootSpanId)) {\n      return;\n    }\n\n    DEBUG_BUILD &&\n      debug.log(\n        `[Profiling] Reached 5-minute timeout for root span ${rootSpanId}. You likely started a manual root span that never called \\`.end()\\`.`,\n      );\n\n    this._activeRootSpanIds.delete(rootSpanId);\n\n    if (this._activeRootSpanIds.size === 0) {\n      this._endProfiling();\n    }\n  }\n\n  /**\n   * Stop current profiler instance, convert profile to chunk & send.\n   */\n  private async _collectCurrentChunk(): Promise<void> {\n    const prevProfiler = this._profiler;\n    this._profiler = undefined;\n\n    if (!prevProfiler) {\n      return;\n    }\n\n    try {\n      const profile = await prevProfiler.stop();\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const chunk = createProfileChunkPayload(profile, this._client!, this._profilerId);\n\n      // Validate chunk before sending\n      const validationReturn = validateProfileChunk(chunk);\n      if ('reason' in validationReturn) {\n        DEBUG_BUILD &&\n          debug.log(\n            '[Profiling] Discarding invalid profile chunk (this is probably a bug in the SDK):',\n            validationReturn.reason,\n          );\n        return;\n      }\n\n      this._sendProfileChunk(chunk);\n\n      DEBUG_BUILD && debug.log('[Profiling] Collected browser profile chunk.');\n    } catch (e) {\n      DEBUG_BUILD && debug.log('[Profiling] Error while stopping JS Profiler for chunk:', e);\n    }\n  }\n\n  /**\n   * Send a profile chunk as a standalone envelope.\n   */\n  private _sendProfileChunk(chunk: ProfileChunk): void {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const client = this._client!;\n\n    const sdkInfo = getSdkMetadataForEnvelopeHeader(client.getSdkMetadata?.());\n    const dsn = client.getDsn();\n    const tunnel = client.getOptions().tunnel;\n\n    const envelope = createEnvelope<ProfileChunkEnvelope>(\n      {\n        event_id: uuid4(),\n        sent_at: new Date().toISOString(),\n        ...(sdkInfo && { sdk: sdkInfo }),\n        ...(!!tunnel && dsn && { dsn: dsnToString(dsn) }),\n      },\n      [[{ type: 'profile_chunk', platform: 'javascript' }, chunk]],\n    );\n\n    client.sendEnvelope(envelope).then(null, reason => {\n      DEBUG_BUILD && debug.error('Error while sending profile chunk envelope:', reason);\n    });\n  }\n}\n"],"names":[],"mappings":"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"}