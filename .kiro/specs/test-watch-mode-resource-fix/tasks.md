# Implementation Plan

- [x] 1. Write bug condition exploration test
  - **Property 1: Fault Condition** - Test Watch Mode Resource Consumption
  - **CRITICAL**: This test MUST FAIL on unfixed code - failure confirms the bug exists
  - **DO NOT attempt to fix the test or the code when it fails**
  - **NOTE**: This test encodes the expected behavior - it will validate the fix when it passes after implementation
  - **GOAL**: Surface counterexamples that demonstrate the bug exists
  - **Scoped PBT Approach**: For deterministic bugs, scope the property to the concrete failing case(s) to ensure reproducibility
  - Test that running vitest without `--run` flag causes watch mode activation (from Fault Condition in design)
  - Test that default resource limits (maxConcurrency: 4, maxWorkers: 4) cause excessive CPU usage on MacBook Pro
  - The test assertions should verify:
    - Process does NOT exit after test completion (watch mode stays active)
    - CPU usage exceeds reasonable thresholds (>150%) with 4 workers
    - Resource consumption is excessive for local development
  - Run test on UNFIXED code
  - **EXPECTED OUTCOME**: Test FAILS (this is correct - it proves the bug exists)
  - Document counterexamples found to understand root cause:
    - Specific commands that trigger watch mode
    - Measured CPU/memory usage with current configuration
    - System performance impact observations
  - Mark task complete when test is written, run, and failure is documented
  - _Requirements: 1.2, 1.3, 1.4_

- [x] 2. Write preservation property tests (BEFORE implementing fix)
  - **Property 2: Preservation** - Watch Mode and CI Performance
  - **IMPORTANT**: Follow observation-first methodology
  - Observe behavior on UNFIXED code for non-buggy inputs:
    - Run `npm run test:watch` and verify it stays in watch mode
    - Run `npm run test:button:watch` and verify continuous execution
    - Run `npm run test:full` and measure execution time with maxConcurrency=4, maxWorkers=4
    - Run `npm test` and verify safety warning appears
  - Write property-based tests capturing observed behavior patterns from Preservation Requirements:
    - For all explicit watch mode commands, process continues running after tests complete
    - For CI command (test:full), resource limits remain at maxConcurrency=4, maxWorkers=4
    - For safety command (npm test), warning message displays and no tests execute
    - Coverage generation continues to work correctly
  - Property-based testing generates many test cases for stronger guarantees
  - Run tests on UNFIXED code
  - **EXPECTED OUTCOME**: Tests PASS (this confirms baseline behavior to preserve)
  - Mark task complete when tests are written, run, and passing on unfixed code
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5_

- [x] 3. Fix for test watch mode resource consumption

  - [x] 3.1 Implement the fix in vitest.config.ts
    - Change `maxConcurrency` from 4 to 2 (safe for local development)
    - Change `maxWorkers` from 4 to 2 (safe for local development)
    - Change `poolOptions.forks.maxForks` from 4 to 2 (matches maxWorkers)
    - Verify that `test:full` command in package.json already has `--maxConcurrency=4 --maxWorkers=4` overrides (no changes needed)
    - Verify that all non-watch test commands in package.json already have `--run` flag (no changes needed)
    - _Bug_Condition: isBugCondition(input) where input.command does NOT contain "--run" flag AND input.environment == "local_development" AND vitest enters watch mode AND process does NOT exit after test completion_
    - _Expected_Behavior: Tests run once and exit immediately after completion, releasing all CPU and memory resources (from Expected Behavior Properties in design)_
    - _Preservation: Watch mode commands continue working, CI performance maintained with command-line overrides, safety warning preserved (from Preservation Requirements in design)_
    - _Requirements: 2.2, 2.3, 2.4, 3.1, 3.2, 3.3, 3.4, 3.5_

  - [x] 3.2 Verify bug condition exploration test now passes
    - **Property 1: Expected Behavior** - Tests Exit After Completion with Safe Resource Limits
    - **IMPORTANT**: Re-run the SAME test from task 1 - do NOT write a new test
    - The test from task 1 encodes the expected behavior
    - When this test passes, it confirms the expected behavior is satisfied:
      - Tests exit after completion (no indefinite watch mode)
      - CPU usage is reasonable (<150%) with 2 workers
      - Resource consumption is safe for local development
    - Run bug condition exploration test from step 1
    - **EXPECTED OUTCOME**: Test PASSES (confirms bug is fixed)
    - _Requirements: 2.2, 2.3, 2.4_

  - [x] 3.3 Verify preservation tests still pass
    - **Property 2: Preservation** - Watch Mode and CI Performance Unchanged
    - **IMPORTANT**: Re-run the SAME tests from task 2 - do NOT write new tests
    - Run preservation property tests from step 2
    - **EXPECTED OUTCOME**: Tests PASS (confirms no regressions)
    - Verify:
      - Watch mode commands still run continuously
      - CI command (test:full) still uses maxConcurrency=4, maxWorkers=4 via overrides
      - Safety warning still appears for `npm test`
      - Coverage generation still works correctly
    - Confirm all tests still pass after fix (no regressions)

- [x] 4. Checkpoint - Ensure all tests pass
  - Run `npm run test:safe` to verify all tests pass with new default resource limits
  - Run `npm run test:full` to verify CI performance is maintained with overrides
  - Manually test watch mode commands to ensure they still work correctly
  - Monitor CPU and memory usage during test execution to confirm resource consumption is reasonable
  - Ensure all tests pass, ask the user if questions arise
