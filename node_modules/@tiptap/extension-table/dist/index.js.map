{"version":3,"sources":["../src/cell/table-cell.ts","../src/header/table-header.ts","../src/kit/index.ts","../src/row/table-row.ts","../src/table/table.ts","../src/table/utilities/colStyle.ts","../src/table/TableView.ts","../src/table/utilities/createColGroup.ts","../src/table/utilities/createCell.ts","../src/table/utilities/getTableNodeTypes.ts","../src/table/utilities/createTable.ts","../src/table/utilities/deleteTableWhenAllCellsSelected.ts","../src/table/utilities/isCellSelection.ts","../src/table/utilities/markdown.ts"],"sourcesContent":["import '../types.js'\n\nimport { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface TableCellOptions {\n  /**\n   * The HTML attributes for a table cell node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\n/**\n * This extension allows you to create table cells.\n * @see https://www.tiptap.dev/api/nodes/table-cell\n */\nexport const TableCell = Node.create<TableCellOptions>({\n  name: 'tableCell',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'block+',\n\n  addAttributes() {\n    return {\n      colspan: {\n        default: 1,\n      },\n      rowspan: {\n        default: 1,\n      },\n      colwidth: {\n        default: null,\n        parseHTML: element => {\n          const colwidth = element.getAttribute('colwidth')\n          const value = colwidth ? colwidth.split(',').map(width => parseInt(width, 10)) : null\n\n          // if there is no colwidth attribute on the cell, try to get it from the colgroup\n          if (!value) {\n            const cols = element.closest('table')?.querySelectorAll('colgroup > col')\n            const cellIndex = Array.from(element.parentElement?.children || []).indexOf(element)\n\n            if (cellIndex && cellIndex > -1 && cols && cols[cellIndex]) {\n              const colWidth = cols[cellIndex].getAttribute('width')\n              return colWidth ? [parseInt(colWidth, 10)] : null\n            }\n          }\n\n          return value\n        },\n      },\n    }\n  },\n\n  tableRole: 'cell',\n\n  isolating: true,\n\n  parseHTML() {\n    return [{ tag: 'td' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['td', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n})\n","import '../types.js'\n\nimport { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface TableHeaderOptions {\n  /**\n   * The HTML attributes for a table header node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\n/**\n * This extension allows you to create table headers.\n * @see https://www.tiptap.dev/api/nodes/table-header\n */\nexport const TableHeader = Node.create<TableHeaderOptions>({\n  name: 'tableHeader',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'block+',\n\n  addAttributes() {\n    return {\n      colspan: {\n        default: 1,\n      },\n      rowspan: {\n        default: 1,\n      },\n      colwidth: {\n        default: null,\n        parseHTML: element => {\n          const colwidth = element.getAttribute('colwidth')\n          const value = colwidth ? colwidth.split(',').map(width => parseInt(width, 10)) : null\n\n          return value\n        },\n      },\n    }\n  },\n\n  tableRole: 'header_cell',\n\n  isolating: true,\n\n  parseHTML() {\n    return [{ tag: 'th' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['th', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n})\n","import { Extension } from '@tiptap/core'\n\nimport type { TableCellOptions } from '../cell/index.js'\nimport { TableCell } from '../cell/index.js'\nimport type { TableHeaderOptions } from '../header/index.js'\nimport { TableHeader } from '../header/index.js'\nimport type { TableRowOptions } from '../row/index.js'\nimport { TableRow } from '../row/index.js'\nimport type { TableOptions } from '../table/index.js'\nimport { Table } from '../table/index.js'\n\nexport interface TableKitOptions {\n  /**\n   * If set to false, the table extension will not be registered\n   * @example table: false\n   */\n  table: Partial<TableOptions> | false\n  /**\n   * If set to false, the table extension will not be registered\n   * @example tableCell: false\n   */\n  tableCell: Partial<TableCellOptions> | false\n  /**\n   * If set to false, the table extension will not be registered\n   * @example tableHeader: false\n   */\n  tableHeader: Partial<TableHeaderOptions> | false\n  /**\n   * If set to false, the table extension will not be registered\n   * @example tableRow: false\n   */\n  tableRow: Partial<TableRowOptions> | false\n}\n\n/**\n * The table kit is a collection of table editor extensions.\n *\n * Itâ€™s a good starting point for building your own table in Tiptap.\n */\nexport const TableKit = Extension.create<TableKitOptions>({\n  name: 'tableKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.table !== false) {\n      extensions.push(Table.configure(this.options.table))\n    }\n\n    if (this.options.tableCell !== false) {\n      extensions.push(TableCell.configure(this.options.tableCell))\n    }\n\n    if (this.options.tableHeader !== false) {\n      extensions.push(TableHeader.configure(this.options.tableHeader))\n    }\n\n    if (this.options.tableRow !== false) {\n      extensions.push(TableRow.configure(this.options.tableRow))\n    }\n\n    return extensions\n  },\n})\n","import '../types.js'\n\nimport { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface TableRowOptions {\n  /**\n   * The HTML attributes for a table row node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\n/**\n * This extension allows you to create table rows.\n * @see https://www.tiptap.dev/api/nodes/table-row\n */\nexport const TableRow = Node.create<TableRowOptions>({\n  name: 'tableRow',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: '(tableCell | tableHeader)*',\n\n  tableRole: 'row',\n\n  parseHTML() {\n    return [{ tag: 'tr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['tr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n})\n","import '../types.js'\n\nimport {\n  type JSONContent,\n  type MarkdownToken,\n  callOrReturn,\n  getExtensionField,\n  mergeAttributes,\n  Node,\n} from '@tiptap/core'\nimport type { DOMOutputSpec, Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport {\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  CellSelection,\n  columnResizing,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  fixTables,\n  goToNextCell,\n  mergeCells,\n  setCellAttr,\n  splitCell,\n  tableEditing,\n  toggleHeader,\n  toggleHeaderCell,\n} from '@tiptap/pm/tables'\nimport type { EditorView, NodeView } from '@tiptap/pm/view'\n\nimport { TableView } from './TableView.js'\nimport { createColGroup } from './utilities/createColGroup.js'\nimport { createTable } from './utilities/createTable.js'\nimport { deleteTableWhenAllCellsSelected } from './utilities/deleteTableWhenAllCellsSelected.js'\nimport renderTableToMarkdown from './utilities/markdown.js'\n\ntype MarkdownTableToken = {\n  header?: { tokens: MarkdownToken[] }[]\n  rows?: { tokens: MarkdownToken[] }[][]\n} & MarkdownToken\n\nexport interface TableOptions {\n  /**\n   * HTML attributes for the table element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Enables the resizing of tables.\n   * @default false\n   * @example true\n   */\n  resizable: boolean\n\n  /**\n   * Controls whether the table should be wrapped in a div with class \"tableWrapper\" when rendered.\n   * In editable mode with resizable tables, this wrapper is always present via TableView.\n   * @default false\n   * @example true\n   */\n  renderWrapper: boolean\n\n  /**\n   * The width of the resize handle.\n   * @default 5\n   * @example 10\n   */\n  handleWidth: number\n\n  /**\n   * The minimum width of a cell.\n   * @default 25\n   * @example 50\n   */\n  cellMinWidth: number\n\n  /**\n   * The node view to render the table.\n   * @default TableView\n   */\n  View: (new (node: ProseMirrorNode, cellMinWidth: number, view: EditorView) => NodeView) | null\n\n  /**\n   * Enables the resizing of the last column.\n   * @default true\n   * @example false\n   */\n  lastColumnResizable: boolean\n\n  /**\n   * Allow table node selection.\n   * @default false\n   * @example true\n   */\n  allowTableNodeSelection: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    table: {\n      /**\n       * Insert a table\n       * @param options The table attributes\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.insertTable({ rows: 3, cols: 3, withHeaderRow: true })\n       */\n      insertTable: (options?: { rows?: number; cols?: number; withHeaderRow?: boolean }) => ReturnType\n\n      /**\n       * Add a column before the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addColumnBefore()\n       */\n      addColumnBefore: () => ReturnType\n\n      /**\n       * Add a column after the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addColumnAfter()\n       */\n      addColumnAfter: () => ReturnType\n\n      /**\n       * Delete the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteColumn()\n       */\n      deleteColumn: () => ReturnType\n\n      /**\n       * Add a row before the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addRowBefore()\n       */\n      addRowBefore: () => ReturnType\n\n      /**\n       * Add a row after the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addRowAfter()\n       */\n      addRowAfter: () => ReturnType\n\n      /**\n       * Delete the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteRow()\n       */\n      deleteRow: () => ReturnType\n\n      /**\n       * Delete the current table\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteTable()\n       */\n      deleteTable: () => ReturnType\n\n      /**\n       * Merge the currently selected cells\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.mergeCells()\n       */\n      mergeCells: () => ReturnType\n\n      /**\n       * Split the currently selected cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.splitCell()\n       */\n      splitCell: () => ReturnType\n\n      /**\n       * Toggle the header column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderColumn()\n       */\n      toggleHeaderColumn: () => ReturnType\n\n      /**\n       * Toggle the header row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderRow()\n       */\n      toggleHeaderRow: () => ReturnType\n\n      /**\n       * Toggle the header cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderCell()\n       */\n      toggleHeaderCell: () => ReturnType\n\n      /**\n       * Merge or split the currently selected cells\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.mergeOrSplit()\n       */\n      mergeOrSplit: () => ReturnType\n\n      /**\n       * Set a cell attribute\n       * @param name The attribute name\n       * @param value The attribute value\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.setCellAttribute('align', 'right')\n       */\n      setCellAttribute: (name: string, value: any) => ReturnType\n\n      /**\n       * Moves the selection to the next cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.goToNextCell()\n       */\n      goToNextCell: () => ReturnType\n\n      /**\n       * Moves the selection to the previous cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.goToPreviousCell()\n       */\n      goToPreviousCell: () => ReturnType\n\n      /**\n       * Try to fix the table structure if necessary\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.fixTables()\n       */\n      fixTables: () => ReturnType\n\n      /**\n       * Set a cell selection inside the current table\n       * @param position The cell position\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.setCellSelection({ anchorCell: 1, headCell: 2 })\n       */\n      setCellSelection: (position: { anchorCell: number; headCell?: number }) => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create tables.\n * @see https://www.tiptap.dev/api/nodes/table\n */\nexport const Table = Node.create<TableOptions>({\n  name: 'table',\n\n  // @ts-ignore\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      resizable: false,\n      renderWrapper: false,\n      handleWidth: 5,\n      cellMinWidth: 25,\n      // TODO: fix\n      View: TableView,\n      lastColumnResizable: true,\n      allowTableNodeSelection: false,\n    }\n  },\n\n  content: 'tableRow+',\n\n  tableRole: 'table',\n\n  isolating: true,\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'table' }]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth)\n\n    const userStyles = HTMLAttributes.style as string | undefined\n\n    function getTableStyle() {\n      if (userStyles) {\n        return userStyles\n      }\n\n      return tableWidth ? `width: ${tableWidth}` : `min-width: ${tableMinWidth}`\n    }\n\n    const table: DOMOutputSpec = [\n      'table',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        style: getTableStyle(),\n      }),\n      colgroup,\n      ['tbody', 0],\n    ]\n\n    return this.options.renderWrapper ? ['div', { class: 'tableWrapper' }, table] : table\n  },\n\n  parseMarkdown: (token: MarkdownTableToken, h) => {\n    const rows = []\n\n    if (token.header) {\n      const headerCells: JSONContent[] = []\n\n      token.header.forEach(cell => {\n        headerCells.push(h.createNode('tableHeader', {}, [{ type: 'paragraph', content: h.parseInline(cell.tokens) }]))\n      })\n\n      rows.push(h.createNode('tableRow', {}, headerCells))\n    }\n\n    if (token.rows) {\n      token.rows.forEach(row => {\n        const bodyCells: JSONContent[] = []\n        row.forEach(cell => {\n          bodyCells.push(h.createNode('tableCell', {}, [{ type: 'paragraph', content: h.parseInline(cell.tokens) }]))\n        })\n        rows.push(h.createNode('tableRow', {}, bodyCells))\n      })\n    }\n\n    return h.createNode('table', undefined, rows)\n  },\n\n  renderMarkdown: (node, h) => {\n    return renderTableToMarkdown(node, h)\n  },\n\n  addCommands() {\n    return {\n      insertTable:\n        ({ rows = 3, cols = 3, withHeaderRow = true } = {}) =>\n        ({ tr, dispatch, editor }) => {\n          const node = createTable(editor.schema, rows, cols, withHeaderRow)\n\n          if (dispatch) {\n            const offset = tr.selection.from + 1\n\n            tr.replaceSelectionWith(node)\n              .scrollIntoView()\n              .setSelection(TextSelection.near(tr.doc.resolve(offset)))\n          }\n\n          return true\n        },\n      addColumnBefore:\n        () =>\n        ({ state, dispatch }) => {\n          return addColumnBefore(state, dispatch)\n        },\n      addColumnAfter:\n        () =>\n        ({ state, dispatch }) => {\n          return addColumnAfter(state, dispatch)\n        },\n      deleteColumn:\n        () =>\n        ({ state, dispatch }) => {\n          return deleteColumn(state, dispatch)\n        },\n      addRowBefore:\n        () =>\n        ({ state, dispatch }) => {\n          return addRowBefore(state, dispatch)\n        },\n      addRowAfter:\n        () =>\n        ({ state, dispatch }) => {\n          return addRowAfter(state, dispatch)\n        },\n      deleteRow:\n        () =>\n        ({ state, dispatch }) => {\n          return deleteRow(state, dispatch)\n        },\n      deleteTable:\n        () =>\n        ({ state, dispatch }) => {\n          return deleteTable(state, dispatch)\n        },\n      mergeCells:\n        () =>\n        ({ state, dispatch }) => {\n          return mergeCells(state, dispatch)\n        },\n      splitCell:\n        () =>\n        ({ state, dispatch }) => {\n          return splitCell(state, dispatch)\n        },\n      toggleHeaderColumn:\n        () =>\n        ({ state, dispatch }) => {\n          return toggleHeader('column')(state, dispatch)\n        },\n      toggleHeaderRow:\n        () =>\n        ({ state, dispatch }) => {\n          return toggleHeader('row')(state, dispatch)\n        },\n      toggleHeaderCell:\n        () =>\n        ({ state, dispatch }) => {\n          return toggleHeaderCell(state, dispatch)\n        },\n      mergeOrSplit:\n        () =>\n        ({ state, dispatch }) => {\n          if (mergeCells(state, dispatch)) {\n            return true\n          }\n\n          return splitCell(state, dispatch)\n        },\n      setCellAttribute:\n        (name, value) =>\n        ({ state, dispatch }) => {\n          return setCellAttr(name, value)(state, dispatch)\n        },\n      goToNextCell:\n        () =>\n        ({ state, dispatch }) => {\n          return goToNextCell(1)(state, dispatch)\n        },\n      goToPreviousCell:\n        () =>\n        ({ state, dispatch }) => {\n          return goToNextCell(-1)(state, dispatch)\n        },\n      fixTables:\n        () =>\n        ({ state, dispatch }) => {\n          if (dispatch) {\n            fixTables(state)\n          }\n\n          return true\n        },\n      setCellSelection:\n        position =>\n        ({ tr, dispatch }) => {\n          if (dispatch) {\n            const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell)\n\n            // @ts-ignore\n            tr.setSelection(selection)\n          }\n\n          return true\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Tab: () => {\n        if (this.editor.commands.goToNextCell()) {\n          return true\n        }\n\n        if (!this.editor.can().addRowAfter()) {\n          return false\n        }\n\n        return this.editor.chain().addRowAfter().goToNextCell().run()\n      },\n      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n      Backspace: deleteTableWhenAllCellsSelected,\n      'Mod-Backspace': deleteTableWhenAllCellsSelected,\n      Delete: deleteTableWhenAllCellsSelected,\n      'Mod-Delete': deleteTableWhenAllCellsSelected,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const isResizable = this.options.resizable && this.editor.isEditable\n\n    return [\n      ...(isResizable\n        ? [\n            columnResizing({\n              handleWidth: this.options.handleWidth,\n              cellMinWidth: this.options.cellMinWidth,\n              defaultCellMinWidth: this.options.cellMinWidth,\n              View: this.options.View,\n              lastColumnResizable: this.options.lastColumnResizable,\n            }),\n          ]\n        : []),\n      tableEditing({\n        allowTableNodeSelection: this.options.allowTableNodeSelection,\n      }),\n    ]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\n    }\n  },\n})\n","export function getColStyleDeclaration(minWidth: number, width: number | undefined): [string, string] {\n  if (width) {\n    // apply the stored width unless it is below the configured minimum cell width\n    return ['width', `${Math.max(width, minWidth)}px`]\n  }\n\n  // set the minimum with on the column if it has no stored width\n  return ['min-width', `${minWidth}px`]\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport type { NodeView, ViewMutationRecord } from '@tiptap/pm/view'\n\nimport { getColStyleDeclaration } from './utilities/colStyle.js'\n\nexport function updateColumns(\n  node: ProseMirrorNode,\n  colgroup: HTMLTableColElement, // <colgroup> has the same prototype as <col>\n  table: HTMLTableElement,\n  cellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n) {\n  let totalWidth = 0\n  let fixedWidth = true\n  let nextDOM = colgroup.firstChild\n  const row = node.firstChild\n\n  if (row !== null) {\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\n      const { colspan, colwidth } = row.child(i).attrs\n\n      for (let j = 0; j < colspan; j += 1, col += 1) {\n        const hasWidth = overrideCol === col ? overrideValue : ((colwidth && colwidth[j]) as number | undefined)\n        const cssWidth = hasWidth ? `${hasWidth}px` : ''\n\n        totalWidth += hasWidth || cellMinWidth\n\n        if (!hasWidth) {\n          fixedWidth = false\n        }\n\n        if (!nextDOM) {\n          const colElement = document.createElement('col')\n\n          const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth)\n\n          colElement.style.setProperty(propertyKey, propertyValue)\n\n          colgroup.appendChild(colElement)\n        } else {\n          if ((nextDOM as HTMLTableColElement).style.width !== cssWidth) {\n            const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth)\n\n            ;(nextDOM as HTMLTableColElement).style.setProperty(propertyKey, propertyValue)\n          }\n\n          nextDOM = nextDOM.nextSibling\n        }\n      }\n    }\n  }\n\n  while (nextDOM) {\n    const after = nextDOM.nextSibling\n\n    nextDOM.parentNode?.removeChild(nextDOM)\n    nextDOM = after\n  }\n\n  // Check if user has set a width style on the table node\n  const hasUserWidth = node.attrs.style && typeof node.attrs.style === 'string' && /\\bwidth\\s*:/i.test(node.attrs.style)\n\n  if (fixedWidth && !hasUserWidth) {\n    table.style.width = `${totalWidth}px`\n    table.style.minWidth = ''\n  } else {\n    table.style.width = ''\n    table.style.minWidth = `${totalWidth}px`\n  }\n}\n\nexport class TableView implements NodeView {\n  node: ProseMirrorNode\n\n  cellMinWidth: number\n\n  dom: HTMLDivElement\n\n  table: HTMLTableElement\n\n  colgroup: HTMLTableColElement\n\n  contentDOM: HTMLTableSectionElement\n\n  constructor(node: ProseMirrorNode, cellMinWidth: number) {\n    this.node = node\n    this.cellMinWidth = cellMinWidth\n    this.dom = document.createElement('div')\n    this.dom.className = 'tableWrapper'\n    this.table = this.dom.appendChild(document.createElement('table'))\n\n    // Apply user styles to the table element\n    if (node.attrs.style) {\n      this.table.style.cssText = node.attrs.style\n    }\n\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'))\n    updateColumns(node, this.colgroup, this.table, cellMinWidth)\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'))\n  }\n\n  update(node: ProseMirrorNode) {\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    this.node = node\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth)\n\n    return true\n  }\n\n  ignoreMutation(mutation: ViewMutationRecord) {\n    const target = mutation.target as Node\n    const isInsideWrapper = this.dom.contains(target)\n    const isInsideContent = this.contentDOM.contains(target)\n\n    if (isInsideWrapper && !isInsideContent) {\n      if (mutation.type === 'attributes' || mutation.type === 'childList' || mutation.type === 'characterData') {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n","import type { DOMOutputSpec, Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { getColStyleDeclaration } from './colStyle.js'\n\nexport type ColGroup =\n  | {\n      colgroup: DOMOutputSpec\n      tableWidth: string\n      tableMinWidth: string\n    }\n  | Record<string, never>\n\n/**\n * Creates a colgroup element for a table node in ProseMirror.\n *\n * @param node - The ProseMirror node representing the table.\n * @param cellMinWidth - The minimum width of a cell in the table.\n * @param overrideCol - (Optional) The index of the column to override the width of.\n * @param overrideValue - (Optional) The width value to use for the overridden column.\n * @returns An object containing the colgroup element, the total width of the table, and the minimum width of the table.\n */\nexport function createColGroup(node: ProseMirrorNode, cellMinWidth: number): ColGroup\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n  overrideCol: number,\n  overrideValue: number,\n): ColGroup\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n): ColGroup {\n  let totalWidth = 0\n  let fixedWidth = true\n  const cols: DOMOutputSpec[] = []\n  const row = node.firstChild\n\n  if (!row) {\n    return {}\n  }\n\n  for (let i = 0, col = 0; i < row.childCount; i += 1) {\n    const { colspan, colwidth } = row.child(i).attrs\n\n    for (let j = 0; j < colspan; j += 1, col += 1) {\n      const hasWidth = overrideCol === col ? overrideValue : colwidth && (colwidth[j] as number | undefined)\n\n      totalWidth += hasWidth || cellMinWidth\n\n      if (!hasWidth) {\n        fixedWidth = false\n      }\n\n      const [property, value] = getColStyleDeclaration(cellMinWidth, hasWidth)\n\n      cols.push(['col', { style: `${property}: ${value}` }])\n    }\n  }\n\n  const tableWidth = fixedWidth ? `${totalWidth}px` : ''\n  const tableMinWidth = fixedWidth ? '' : `${totalWidth}px`\n\n  const colgroup: DOMOutputSpec = ['colgroup', {}, ...cols]\n\n  return { colgroup, tableWidth, tableMinWidth }\n}\n","import type { Fragment, Node as ProsemirrorNode, NodeType } from '@tiptap/pm/model'\n\nexport function createCell(\n  cellType: NodeType,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode | null | undefined {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent)\n  }\n\n  return cellType.createAndFill()\n}\n","import type { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getTableNodeTypes(schema: Schema): { [key: string]: NodeType } {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes\n  }\n\n  const roles: { [key: string]: NodeType } = {}\n\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type]\n\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType\n    }\n  })\n\n  schema.cached.tableNodeTypes = roles\n\n  return roles\n}\n","import type { Fragment, Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\n\nimport { createCell } from './createCell.js'\nimport { getTableNodeTypes } from './getTableNodeTypes.js'\n\nexport function createTable(\n  schema: Schema,\n  rowsCount: number,\n  colsCount: number,\n  withHeaderRow: boolean,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode {\n  const types = getTableNodeTypes(schema)\n  const headerCells: ProsemirrorNode[] = []\n  const cells: ProsemirrorNode[] = []\n\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent)\n\n    if (cell) {\n      cells.push(cell)\n    }\n\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent)\n\n      if (headerCell) {\n        headerCells.push(headerCell)\n      }\n    }\n  }\n\n  const rows: ProsemirrorNode[] = []\n\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells))\n  }\n\n  return types.table.createChecked(null, rows)\n}\n","import type { KeyboardShortcutCommand } from '@tiptap/core'\nimport { findParentNodeClosestToPos } from '@tiptap/core'\n\nimport { isCellSelection } from './isCellSelection.js'\n\nexport const deleteTableWhenAllCellsSelected: KeyboardShortcutCommand = ({ editor }) => {\n  const { selection } = editor.state\n\n  if (!isCellSelection(selection)) {\n    return false\n  }\n\n  let cellCount = 0\n  const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n    return node.type.name === 'table'\n  })\n\n  table?.node.descendants(node => {\n    if (node.type.name === 'table') {\n      return false\n    }\n\n    if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n      cellCount += 1\n    }\n  })\n\n  const allCellsSelected = cellCount === selection.ranges.length\n\n  if (!allCellsSelected) {\n    return false\n  }\n\n  editor.commands.deleteTable()\n\n  return true\n}\n","import { CellSelection } from '@tiptap/pm/tables'\n\nexport function isCellSelection(value: unknown): value is CellSelection {\n  return value instanceof CellSelection\n}\n","import type { JSONContent, MarkdownRendererHelpers } from '@tiptap/core'\n\nexport const DEFAULT_CELL_LINE_SEPARATOR = '\\u001F'\n\nfunction collapseWhitespace(s: string) {\n  return (s || '').replace(/\\s+/g, ' ').trim()\n}\n\nexport function renderTableToMarkdown(\n  node: JSONContent,\n  h: MarkdownRendererHelpers,\n  options: { cellLineSeparator?: string } = {},\n) {\n  const cellSep = options.cellLineSeparator ?? DEFAULT_CELL_LINE_SEPARATOR\n\n  if (!node || !node.content || node.content.length === 0) {\n    return ''\n  }\n\n  // Build rows: each cell is { text, isHeader }\n  const rows: { text: string; isHeader: boolean }[][] = []\n\n  node.content.forEach(rowNode => {\n    const cells: { text: string; isHeader: boolean }[] = []\n\n    if (rowNode.content) {\n      rowNode.content.forEach(cellNode => {\n        let raw = ''\n\n        if (cellNode.content && Array.isArray(cellNode.content) && cellNode.content.length > 1) {\n          // Render each direct child separately and join with separator so we can split again later\n          const parts = cellNode.content.map(child => h.renderChildren(child as unknown as JSONContent))\n          raw = parts.join(cellSep)\n        } else {\n          raw = cellNode.content ? h.renderChildren(cellNode.content as unknown as JSONContent[]) : ''\n        }\n\n        const text = collapseWhitespace(raw)\n        const isHeader = cellNode.type === 'tableHeader'\n\n        cells.push({ text, isHeader })\n      })\n    }\n\n    rows.push(cells)\n  })\n\n  const columnCount = rows.reduce((max, r) => Math.max(max, r.length), 0)\n\n  if (columnCount === 0) {\n    return ''\n  }\n\n  // Compute max width for each column\n  const colWidths = new Array(columnCount).fill(0)\n\n  rows.forEach(r => {\n    for (let i = 0; i < columnCount; i += 1) {\n      const cell = r[i]?.text || ''\n      const len = cell.length\n      if (len > colWidths[i]) {\n        colWidths[i] = len\n      }\n\n      if (colWidths[i] < 3) {\n        colWidths[i] = 3\n      }\n    }\n  })\n\n  const pad = (s: string, width: number) => s + ' '.repeat(Math.max(0, width - s.length))\n\n  const headerRow = rows[0]\n  const hasHeader = headerRow.some(c => c.isHeader)\n\n  let out = '\\n'\n\n  // Render header: if the document has a header row (tableHeader cells) use it,\n  // otherwise emit an empty header row so most Markdown parsers will recognize\n  // the table (this makes roundtripping to Markdown -> JSON more reliable).\n  const headerTexts = new Array(columnCount)\n    .fill(0)\n    .map((_, i) => (hasHeader ? (headerRow[i] && headerRow[i].text) || '' : ''))\n\n  out += `| ${headerTexts.map((t, i) => pad(t, colWidths[i])).join(' | ')} |\\n`\n\n  // Separator (use at least 3 dashes per column)\n  out += `| ${colWidths.map(w => '-'.repeat(Math.max(3, w))).join(' | ')} |\\n`\n\n  // Body rows: if we had a header, skip the first row; otherwise render all rows\n  const body = hasHeader ? rows.slice(1) : rows\n  body.forEach(r => {\n    out += `| ${new Array(columnCount)\n      .fill(0)\n      .map((_, i) => pad((r[i] && r[i].text) || '', colWidths[i]))\n      .join(' | ')} |\\n`\n  })\n\n  return out\n}\n\nexport default renderTableToMarkdown\n"],"mappings":"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","names":["mergeAttributes","Node","mergeAttributes","Node","mergeAttributes","Node","CellSelection","_a","Node","mergeAttributes","CellSelection"]}