{"version":3,"file":"attributes.js","sources":["../../src/attributes.ts"],"sourcesContent":["import type { DurationUnit, FractionUnit, InformationUnit } from './types-hoist/measurement';\n\nexport type RawAttributes<T> = T & ValidatedAttributes<T>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type RawAttribute<T> = T extends { value: any } | { unit: any } ? AttributeObject : T;\n\nexport type Attributes = Record<string, TypedAttributeValue>;\n\nexport type AttributeValueType = string | number | boolean | Array<string> | Array<number> | Array<boolean>;\n\ntype AttributeTypeMap = {\n  string: string;\n  integer: number;\n  double: number;\n  boolean: boolean;\n  'string[]': Array<string>;\n  'integer[]': Array<number>;\n  'double[]': Array<number>;\n  'boolean[]': Array<boolean>;\n};\n\n/* Generates a type from the AttributeTypeMap like:\n  | { value: string; type: 'string' }\n  | { value: number; type: 'integer' }\n  | { value: number; type: 'double' }\n */\ntype AttributeUnion = {\n  [K in keyof AttributeTypeMap]: {\n    value: AttributeTypeMap[K];\n    type: K;\n  };\n}[keyof AttributeTypeMap];\n\nexport type TypedAttributeValue = AttributeUnion & { unit?: AttributeUnit };\n\nexport type AttributeObject = {\n  value: unknown;\n  unit?: AttributeUnit;\n};\n\n// Unfortunately, we loose type safety if we did something like Exclude<MeasurementUnit, string>\n// so therefore we unionize between the three supported unit categories.\ntype AttributeUnit = DurationUnit | InformationUnit | FractionUnit;\n\n/* If an attribute has either a 'value' or 'unit' property, we use the ValidAttributeObject type. */\nexport type ValidatedAttributes<T> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [K in keyof T]: T[K] extends { value: any } | { unit: any } ? AttributeObject : unknown;\n};\n\n/**\n * Type-guard: The attribute object has the shape the official attribute object (value, type, unit).\n * https://develop.sentry.dev/sdk/telemetry/scopes/#setting-attributes\n */\nexport function isAttributeObject(maybeObj: unknown): maybeObj is AttributeObject {\n  return (\n    typeof maybeObj === 'object' &&\n    maybeObj != null &&\n    !Array.isArray(maybeObj) &&\n    Object.keys(maybeObj).includes('value')\n  );\n}\n\n/**\n * Converts an attribute value to a typed attribute value.\n *\n * For now, we intentionally only support primitive values and attribute objects with primitive values.\n * If @param useFallback is true, we stringify non-primitive values to a string attribute value. Otherwise\n * we return `undefined` for unsupported values.\n *\n * @param value - The value of the passed attribute.\n * @param useFallback - If true, unsupported values will be stringified to a string attribute value.\n *                      Defaults to false. In this case, `undefined` is returned for unsupported values.\n * @returns The typed attribute.\n */\nexport function attributeValueToTypedAttributeValue(\n  rawValue: unknown,\n  useFallback?: boolean | 'skip-undefined',\n): TypedAttributeValue | void {\n  const { value, unit } = isAttributeObject(rawValue) ? rawValue : { value: rawValue, unit: undefined };\n  const attributeValue = getTypedAttributeValue(value);\n  const checkedUnit = unit && typeof unit === 'string' ? { unit } : {};\n  if (attributeValue) {\n    return { ...attributeValue, ...checkedUnit };\n  }\n\n  if (!useFallback || (useFallback === 'skip-undefined' && value === undefined)) {\n    return;\n  }\n\n  // Fallback: stringify the value\n  // TODO(v11): be smarter here and use String constructor if stringify fails\n  // (this is a breaking change for already existing attribute values)\n  let stringValue = '';\n  try {\n    stringValue = JSON.stringify(value) ?? '';\n  } catch {\n    // Do nothing\n  }\n  return {\n    value: stringValue,\n    type: 'string',\n    ...checkedUnit,\n  };\n}\n\n/**\n * Serializes raw attributes to typed attributes as expected in our envelopes.\n *\n * @param attributes The raw attributes to serialize.\n * @param fallback   If true, unsupported values will be stringified to a string attribute value.\n *                   Defaults to false. In this case, `undefined` is returned for unsupported values.\n *\n * @returns The serialized attributes.\n */\nexport function serializeAttributes<T>(\n  attributes: RawAttributes<T> | undefined,\n  fallback: boolean | 'skip-undefined' = false,\n): Attributes {\n  const serializedAttributes: Attributes = {};\n  for (const [key, value] of Object.entries(attributes ?? {})) {\n    const typedValue = attributeValueToTypedAttributeValue(value, fallback);\n    if (typedValue) {\n      serializedAttributes[key] = typedValue;\n    }\n  }\n  return serializedAttributes;\n}\n\n/**\n * NOTE: We intentionally do not return anything for non-primitive values:\n *  - array support will come in the future but if we stringify arrays now,\n *    sending arrays (unstringified) later will be a subtle breaking change.\n *  - Objects are not supported yet and product support is still TBD.\n *  - We still keep the type signature for TypedAttributeValue wider to avoid a\n *    breaking change once we add support for non-primitive values.\n *  - Once we go back to supporting arrays and stringifying all other values,\n *    we already implemented the serialization logic here:\n *    https://github.com/getsentry/sentry-javascript/pull/18165\n */\nfunction getTypedAttributeValue(value: unknown): TypedAttributeValue | void {\n  const primitiveType =\n    typeof value === 'string'\n      ? 'string'\n      : typeof value === 'boolean'\n        ? 'boolean'\n        : typeof value === 'number' && !Number.isNaN(value)\n          ? Number.isInteger(value)\n            ? 'integer'\n            : 'double'\n          : null;\n  if (primitiveType) {\n    // @ts-expect-error - TS complains because {@link TypedAttributeValue} is strictly typed to\n    // avoid setting the wrong `type` on the attribute value.\n    // In this case, getPrimitiveType already does the check but TS doesn't know that.\n    // The \"clean\" alternative is to return an object per `typeof value` case\n    // but that would require more bundle size\n    // Therefore, we ignore it.\n    return { value, type: primitiveType };\n  }\n}\n"],"names":[],"mappings":"AAkDA;AACA;AACA;AACA;AACO,SAAS,iBAAiB,CAAC,QAAQ,EAAwC;AAClF,EAAE;AACF,IAAI,OAAO,QAAA,KAAa,QAAA;AACxB,IAAI,QAAA,IAAY,IAAA;AAChB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAA;AAC3B,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,QAAQ,CAAC,OAAO;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,mCAAmC;AACnD,EAAE,QAAQ;AACV,EAAE,WAAW;AACb,EAA8B;AAC9B,EAAE,MAAM,EAAE,KAAK,EAAE,MAAK,GAAI,iBAAiB,CAAC,QAAQ,CAAA,GAAI,QAAA,GAAW,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAA,EAAW;AACvG,EAAE,MAAM,cAAA,GAAiB,sBAAsB,CAAC,KAAK,CAAC;AACtD,EAAE,MAAM,WAAA,GAAc,IAAA,IAAQ,OAAO,IAAA,KAAS,QAAA,GAAW,EAAE,IAAA,EAAK,GAAI,EAAE;AACtE,EAAE,IAAI,cAAc,EAAE;AACtB,IAAI,OAAO,EAAE,GAAG,cAAc,EAAE,GAAG,aAAa;AAChD,EAAE;;AAEF,EAAE,IAAI,CAAC,WAAA,KAAgB,WAAA,KAAgB,gBAAA,IAAoB,KAAA,KAAU,SAAS,CAAC,EAAE;AACjF,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,WAAA,GAAc,EAAE;AACtB,EAAE,IAAI;AACN,IAAI,WAAA,GAAc,IAAI,CAAC,SAAS,CAAC,KAAK,CAAA,IAAK,EAAE;AAC7C,EAAE,EAAE,MAAM;AACV;AACA,EAAE;AACF,EAAE,OAAO;AACT,IAAI,KAAK,EAAE,WAAW;AACtB,IAAI,IAAI,EAAE,QAAQ;AAClB,IAAI,GAAG,WAAW;AAClB,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,mBAAmB;AACnC,EAAE,UAAU;AACZ,EAAE,QAAQ,GAA+B,KAAK;AAC9C,EAAc;AACd,EAAE,MAAM,oBAAoB,GAAe,EAAE;AAC7C,EAAE,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAA,IAAK,MAAM,CAAC,OAAO,CAAC,UAAA,IAAc,EAAE,CAAC,EAAE;AAC/D,IAAI,MAAM,aAAa,mCAAmC,CAAC,KAAK,EAAE,QAAQ,CAAC;AAC3E,IAAI,IAAI,UAAU,EAAE;AACpB,MAAM,oBAAoB,CAAC,GAAG,CAAA,GAAI,UAAU;AAC5C,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,oBAAoB;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sBAAsB,CAAC,KAAK,EAAuC;AAC5E,EAAE,MAAM,aAAA;AACR,IAAI,OAAO,UAAU;AACrB,QAAQ;AACR,QAAQ,OAAO,KAAA,KAAU;AACzB,UAAU;AACV,UAAU,OAAO,KAAA,KAAU,QAAA,IAAY,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK;AAC1D,YAAY,MAAM,CAAC,SAAS,CAAC,KAAK;AAClC,cAAc;AACd,cAAc;AACd,YAAY,IAAI;AAChB,EAAE,IAAI,aAAa,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,eAAe;AACzC,EAAE;AACF;;;;"}