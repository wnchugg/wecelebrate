{"version":3,"file":"instrumentation.js","sources":["../../../src/reactrouter-compat-utils/instrumentation.tsx"],"sourcesContent":["/* eslint-disable max-lines */\n// Inspired from Donnie McNeal's solution:\n// https://gist.github.com/wontondon/e8c4bdf2888875e4c755712e99279536\n\nimport {\n  browserTracingIntegration,\n  startBrowserTracingNavigationSpan,\n  startBrowserTracingPageLoadSpan,\n  WINDOW,\n} from '@sentry/browser';\nimport type { Client, Integration, Span } from '@sentry/core';\nimport {\n  addNonEnumerableProperty,\n  debug,\n  getClient,\n  getCurrentScope,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  spanToJSON,\n} from '@sentry/core';\nimport * as React from 'react';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { hoistNonReactStatics } from '../hoist-non-react-statics';\nimport type {\n  Action,\n  AgnosticDataRouteMatch,\n  CreateRouterFunction,\n  CreateRoutesFromChildren,\n  Location,\n  MatchRoutes,\n  RouteMatch,\n  RouteObject,\n  Router,\n  RouterState,\n  UseEffect,\n  UseLocation,\n  UseNavigationType,\n  UseRoutes,\n} from '../types';\nimport { checkRouteForAsyncHandler } from './lazy-routes';\nimport {\n  clearNavigationContext,\n  getActiveRootSpan,\n  initializeRouterUtils,\n  resolveRouteNameAndSource,\n  setNavigationContext,\n  transactionNameHasWildcard,\n} from './utils';\n\nlet _useEffect: UseEffect;\nlet _useLocation: UseLocation;\nlet _useNavigationType: UseNavigationType;\nlet _createRoutesFromChildren: CreateRoutesFromChildren;\nlet _matchRoutes: MatchRoutes;\n\nlet _enableAsyncRouteHandlers: boolean = false;\nlet _lazyRouteTimeout = 3000;\n\nconst CLIENTS_WITH_INSTRUMENT_NAVIGATION = new WeakSet<Client>();\n\n// Prevents duplicate spans when router.subscribe fires multiple times\nconst activeNavigationSpans = new WeakMap<\n  Client,\n  { span: Span; routeName: string; pathname: string; locationKey: string; isPlaceholder?: boolean }\n>();\n\n// Exported for testing only\nexport const allRoutes = new Set<RouteObject>();\n\n// Tracks lazy route loads to wait before finalizing span names\nconst pendingLazyRouteLoads = new WeakMap<Span, Set<Promise<unknown>>>();\n\n// Tracks deferred lazy route promises that can be resolved when patchRoutesOnNavigation is called\nconst deferredLazyRouteResolvers = new WeakMap<Span, () => void>();\n\n/**\n * Schedules a callback using requestAnimationFrame when available (browser),\n * or falls back to setTimeout for SSR environments (Node.js, createMemoryRouter tests).\n */\nfunction scheduleCallback(callback: () => void): number {\n  if (WINDOW?.requestAnimationFrame) {\n    return WINDOW.requestAnimationFrame(callback);\n  }\n  return setTimeout(callback, 0) as unknown as number;\n}\n\n/**\n * Cancels a scheduled callback, handling both RAF (browser) and timeout (SSR) IDs.\n */\nfunction cancelScheduledCallback(id: number): void {\n  if (WINDOW?.cancelAnimationFrame) {\n    WINDOW.cancelAnimationFrame(id);\n  } else {\n    clearTimeout(id);\n  }\n}\n\n/**\n * Computes location key for duplicate detection. Normalizes undefined/null to empty strings.\n * Exported for testing.\n */\nexport function computeLocationKey(location: Location): string {\n  return `${location.pathname}${location.search || ''}${location.hash || ''}`;\n}\n\n/**\n * Checks if a route name is parameterized (contains route parameters like :id or wildcards like *)\n * vs a raw URL path.\n */\nfunction isParameterizedRoute(routeName: string): boolean {\n  return routeName.includes(':') || routeName.includes('*');\n}\n\n/**\n * Determines if a navigation should be skipped as a duplicate, and if an existing span should be updated.\n * Exported for testing.\n *\n * @returns An object with:\n *   - skip: boolean - Whether to skip creating a new span\n *   - shouldUpdate: boolean - Whether to update the existing span name (wildcard upgrade)\n */\nexport function shouldSkipNavigation(\n  trackedNav:\n    | { span: Span; routeName: string; pathname: string; locationKey: string; isPlaceholder?: boolean }\n    | undefined,\n  locationKey: string,\n  proposedName: string,\n  spanHasEnded: boolean,\n): { skip: boolean; shouldUpdate: boolean } {\n  if (!trackedNav) {\n    return { skip: false, shouldUpdate: false };\n  }\n\n  // Check if this is a duplicate navigation (same location)\n  // 1. If it's a placeholder, it's always a duplicate (we're waiting for the real one)\n  // 2. If it's a real span, it's a duplicate only if it hasn't ended yet\n  const isDuplicate = trackedNav.locationKey === locationKey && (trackedNav.isPlaceholder || !spanHasEnded);\n\n  if (isDuplicate) {\n    // Check if we should update the span name with a better route\n    // Allow updates if:\n    // 1. Current has wildcard and new doesn't (wildcard → parameterized upgrade)\n    // 2. Current is raw path and new is parameterized (raw → parameterized upgrade)\n    // 3. New name is different and more specific (longer, indicating nested routes resolved)\n    const currentHasWildcard = !!trackedNav.routeName && transactionNameHasWildcard(trackedNav.routeName);\n    const proposedHasWildcard = transactionNameHasWildcard(proposedName);\n    const currentIsParameterized = !!trackedNav.routeName && isParameterizedRoute(trackedNav.routeName);\n    const proposedIsParameterized = isParameterizedRoute(proposedName);\n\n    const isWildcardUpgrade = currentHasWildcard && !proposedHasWildcard;\n    const isRawToParameterized = !currentIsParameterized && proposedIsParameterized;\n    const isMoreSpecific =\n      proposedName !== trackedNav.routeName &&\n      proposedName.length > (trackedNav.routeName?.length || 0) &&\n      !proposedHasWildcard;\n\n    const shouldUpdate = !!(trackedNav.routeName && (isWildcardUpgrade || isRawToParameterized || isMoreSpecific));\n\n    return { skip: true, shouldUpdate };\n  }\n\n  return { skip: false, shouldUpdate: false };\n}\n\nexport interface ReactRouterOptions {\n  useEffect: UseEffect;\n  useLocation: UseLocation;\n  useNavigationType: UseNavigationType;\n  createRoutesFromChildren: CreateRoutesFromChildren;\n  matchRoutes: MatchRoutes;\n  /**\n   * Whether to strip the basename from the pathname when creating transactions.\n   *\n   * This is useful for applications that use a basename in their routing setup.\n   * @default false\n   */\n  stripBasename?: boolean;\n  /**\n   * Enables support for async route handlers.\n   *\n   * This allows Sentry to track and instrument routes dynamically resolved from async handlers.\n   * @default false\n   */\n  enableAsyncRouteHandlers?: boolean;\n\n  /**\n   * Maximum time (in milliseconds) to wait for lazy routes to load before finalizing span names.\n   *\n   * - Set to `0` to not wait at all (immediate finalization)\n   * - Set to `Infinity` to wait as long as possible (capped at `finalTimeout` to prevent indefinite hangs)\n   * - Negative values will fall back to the default\n   *\n   * Defaults to 3× the configured `idleTimeout` (default: 3000ms).\n   *\n   * @default idleTimeout * 3\n   */\n  lazyRouteTimeout?: number;\n}\n\ntype V6CompatibleVersion = '6' | '7';\n\nexport function addResolvedRoutesToParent(resolvedRoutes: RouteObject[], parentRoute: RouteObject): void {\n  const existingChildren = parentRoute.children || [];\n\n  const newRoutes = resolvedRoutes.filter(\n    newRoute =>\n      !existingChildren.some(\n        existing =>\n          existing === newRoute ||\n          (newRoute.path && existing.path === newRoute.path) ||\n          (newRoute.id && existing.id === newRoute.id),\n      ),\n  );\n\n  if (newRoutes.length > 0) {\n    parentRoute.children = [...existingChildren, ...newRoutes];\n  }\n}\n\n/** Registers a pending lazy route load promise for a span. */\nfunction trackLazyRouteLoad(span: Span, promise: Promise<unknown>): void {\n  let promises = pendingLazyRouteLoads.get(span);\n  if (!promises) {\n    promises = new Set();\n    pendingLazyRouteLoads.set(span, promises);\n  }\n  promises.add(promise);\n\n  // Clean up when promise resolves/rejects\n  promise.finally(() => {\n    const currentPromises = pendingLazyRouteLoads.get(span);\n    if (currentPromises) {\n      currentPromises.delete(promise);\n    }\n  });\n}\n\n/**\n * Creates a deferred promise for a span that will be resolved when patchRoutesOnNavigation is called.\n * This ensures that patchedEnd waits for patchRoutesOnNavigation to be called before ending the span.\n */\nfunction createDeferredLazyRoutePromise(span: Span): void {\n  const deferredPromise = new Promise<void>(resolve => {\n    deferredLazyRouteResolvers.set(span, resolve);\n  });\n\n  trackLazyRouteLoad(span, deferredPromise);\n}\n\n/**\n * Resolves the deferred lazy route promise for a span.\n * Called when patchRoutesOnNavigation is invoked.\n */\nfunction resolveDeferredLazyRoutePromise(span: Span): void {\n  const resolver = deferredLazyRouteResolvers.get(span);\n  if (resolver) {\n    resolver();\n    deferredLazyRouteResolvers.delete(span);\n    // Clear the flag so patchSpanEnd doesn't wait unnecessarily for routes that have already loaded\n    if ((span as unknown as Record<string, boolean>).__sentry_may_have_lazy_routes__) {\n      (span as unknown as Record<string, boolean>).__sentry_may_have_lazy_routes__ = false;\n    }\n  }\n}\n\n/**\n * Processes resolved routes by adding them to allRoutes and checking for nested async handlers.\n * When capturedSpan is provided, updates that specific span instead of the current active span.\n * This prevents race conditions where a lazy handler resolves after the user has navigated away.\n */\nexport function processResolvedRoutes(\n  resolvedRoutes: RouteObject[],\n  parentRoute?: RouteObject,\n  currentLocation: Location | null = null,\n  capturedSpan?: Span,\n): void {\n  resolvedRoutes.forEach(child => {\n    allRoutes.add(child);\n    // Only check for async handlers if the feature is enabled\n    if (_enableAsyncRouteHandlers) {\n      checkRouteForAsyncHandler(child, processResolvedRoutes);\n    }\n  });\n\n  if (parentRoute) {\n    // If a parent route is provided, add the resolved routes as children to the parent route\n    addResolvedRoutesToParent(resolvedRoutes, parentRoute);\n  }\n\n  // Use captured span if provided, otherwise fall back to current active span\n  const targetSpan = capturedSpan ?? getActiveRootSpan();\n  if (targetSpan) {\n    const spanJson = spanToJSON(targetSpan);\n\n    // Skip update if span has already ended (timestamp is set when span.end() is called)\n    if (spanJson.timestamp) {\n      DEBUG_BUILD && debug.warn('[React Router] Lazy handler resolved after span ended - skipping update');\n      return;\n    }\n\n    const spanOp = spanJson.op;\n\n    // Use captured location for route matching (ensures we match against the correct route)\n    // Fall back to window.location only if no captured location and no captured span\n    // (i.e., this is not from an async handler)\n    let location = currentLocation;\n    if (!location && !capturedSpan) {\n      if (typeof WINDOW !== 'undefined') {\n        const globalLocation = WINDOW.location;\n        if (globalLocation?.pathname) {\n          location = { pathname: globalLocation.pathname };\n        }\n      }\n    }\n\n    if (location) {\n      if (spanOp === 'pageload') {\n        // Re-run the pageload transaction update with the newly loaded routes\n        updatePageloadTransaction({\n          activeRootSpan: targetSpan,\n          location: { pathname: location.pathname },\n          routes: Array.from(allRoutes),\n          allRoutes: Array.from(allRoutes),\n        });\n      } else if (spanOp === 'navigation') {\n        // For navigation spans, update the name with the newly loaded routes\n        updateNavigationSpan(targetSpan, location, Array.from(allRoutes), false, _matchRoutes);\n      }\n    }\n  }\n}\n\n/**\n * Updates a navigation span with the correct route name after lazy routes have been loaded.\n */\nexport function updateNavigationSpan(\n  activeRootSpan: Span,\n  location: Location,\n  allRoutes: RouteObject[],\n  forceUpdate = false,\n  matchRoutes: MatchRoutes,\n): void {\n  const spanJson = spanToJSON(activeRootSpan);\n  const currentName = spanJson.description;\n\n  const hasBeenNamed = (activeRootSpan as { __sentry_navigation_name_set__?: boolean })?.__sentry_navigation_name_set__;\n  const currentNameHasWildcard = currentName && transactionNameHasWildcard(currentName);\n  const shouldUpdate = !hasBeenNamed || forceUpdate || currentNameHasWildcard;\n\n  if (shouldUpdate && !spanJson.timestamp) {\n    const currentBranches = matchRoutes(allRoutes, location);\n    const [name, source] = resolveRouteNameAndSource(\n      location,\n      allRoutes,\n      allRoutes,\n      (currentBranches as RouteMatch[]) || [],\n      '',\n    );\n\n    const currentSource = spanJson.data?.[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    const isImprovement =\n      name &&\n      (!currentName || // No current name - always set\n        (!hasBeenNamed && (currentSource !== 'route' || source === 'route')) || // Not finalized - allow unless downgrading route→url\n        (currentSource !== 'route' && source === 'route') || // URL → route upgrade\n        (currentSource === 'route' && source === 'route' && currentNameHasWildcard)); // Route → better route (only if current has wildcard)\n    if (isImprovement) {\n      activeRootSpan.updateName(name);\n      activeRootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n\n      // Only mark as finalized for non-wildcard route names (allows URL→route upgrades).\n      if (!transactionNameHasWildcard(name) && source === 'route') {\n        addNonEnumerableProperty(\n          activeRootSpan as { __sentry_navigation_name_set__?: boolean },\n          '__sentry_navigation_name_set__',\n          true,\n        );\n      }\n    }\n  }\n}\n\nfunction setupRouterSubscription(\n  router: Router,\n  routes: RouteObject[],\n  version: V6CompatibleVersion,\n  basename: string | undefined,\n  activeRootSpan: Span | undefined,\n): void {\n  let isInitialPageloadComplete = false;\n  let hasSeenPageloadSpan = !!activeRootSpan && spanToJSON(activeRootSpan).op === 'pageload';\n  let hasSeenPopAfterPageload = false;\n  let scheduledNavigationHandler: number | null = null;\n  let lastHandledPathname: string | null = null;\n\n  router.subscribe((state: RouterState) => {\n    if (!isInitialPageloadComplete) {\n      const currentRootSpan = getActiveRootSpan();\n      const isCurrentlyInPageload = currentRootSpan && spanToJSON(currentRootSpan).op === 'pageload';\n\n      if (isCurrentlyInPageload) {\n        hasSeenPageloadSpan = true;\n      } else if (hasSeenPageloadSpan) {\n        if (state.historyAction === 'POP' && !hasSeenPopAfterPageload) {\n          hasSeenPopAfterPageload = true;\n        } else {\n          isInitialPageloadComplete = true;\n        }\n      }\n    }\n\n    const shouldHandleNavigation =\n      state.historyAction === 'PUSH' || (state.historyAction === 'POP' && isInitialPageloadComplete);\n\n    if (shouldHandleNavigation) {\n      // Include search and hash to allow query/hash-only navigations\n      // Use computeLocationKey() to ensure undefined/null values are normalized to empty strings\n      const currentLocationKey = computeLocationKey(state.location);\n      const navigationHandler = (): void => {\n        // Prevent multiple calls for the same location within the same navigation cycle\n        if (lastHandledPathname === currentLocationKey) {\n          return;\n        }\n        lastHandledPathname = currentLocationKey;\n        scheduledNavigationHandler = null;\n        handleNavigation({\n          location: state.location,\n          routes,\n          navigationType: state.historyAction,\n          version,\n          basename,\n          allRoutes: Array.from(allRoutes),\n        });\n      };\n\n      if (state.navigation.state !== 'idle') {\n        // Navigation in progress - reset if location changed\n        if (lastHandledPathname !== currentLocationKey) {\n          lastHandledPathname = null;\n        }\n        // Cancel any previously scheduled handler to avoid duplicates\n        if (scheduledNavigationHandler !== null) {\n          cancelScheduledCallback(scheduledNavigationHandler);\n        }\n        scheduledNavigationHandler = scheduleCallback(navigationHandler);\n      } else {\n        // Navigation completed - cancel scheduled handler if any, then call immediately\n        if (scheduledNavigationHandler !== null) {\n          cancelScheduledCallback(scheduledNavigationHandler);\n          scheduledNavigationHandler = null;\n        }\n        navigationHandler();\n        // Don't reset - next navigation cycle resets to prevent duplicates within same cycle.\n      }\n    }\n  });\n}\n\n/**\n * Creates a wrapCreateBrowserRouter function that can be used with all React Router v6 compatible versions.\n */\nexport function createV6CompatibleWrapCreateBrowserRouter<\n  TState extends RouterState = RouterState,\n  TRouter extends Router<TState> = Router<TState>,\n>(\n  createRouterFunction: CreateRouterFunction<TState, TRouter>,\n  version: V6CompatibleVersion,\n): CreateRouterFunction<TState, TRouter> {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(\n        `reactRouterV${version}Instrumentation was unable to wrap the \\`createRouter\\` function because of one or more missing parameters.`,\n      );\n\n    return createRouterFunction;\n  }\n\n  return function (routes: RouteObject[], opts?: Record<string, unknown> & { basename?: string }): TRouter {\n    addRoutesToAllRoutes(routes);\n\n    if (_enableAsyncRouteHandlers) {\n      for (const route of routes) {\n        checkRouteForAsyncHandler(route, processResolvedRoutes);\n      }\n    }\n\n    // Capture the active span BEFORE creating the router.\n    // This is important because the span might end (due to idle timeout) before\n    // patchRoutesOnNavigation is called by React Router.\n    const activeRootSpan = getActiveRootSpan();\n\n    // If patchRoutesOnNavigation is provided and we have an active span,\n    // mark the span as having potential lazy routes and create a deferred promise.\n    const hasPatchRoutesOnNavigation =\n      opts && 'patchRoutesOnNavigation' in opts && typeof opts.patchRoutesOnNavigation === 'function';\n    if (hasPatchRoutesOnNavigation && activeRootSpan) {\n      // Mark the span as potentially having lazy routes\n      addNonEnumerableProperty(\n        activeRootSpan as unknown as Record<string, boolean>,\n        '__sentry_may_have_lazy_routes__',\n        true,\n      );\n      createDeferredLazyRoutePromise(activeRootSpan);\n    }\n\n    // Pass the captured span to wrapPatchRoutesOnNavigation so it uses the same span\n    // even if the span has ended by the time patchRoutesOnNavigation is called.\n    const wrappedOpts = wrapPatchRoutesOnNavigation(opts, false, activeRootSpan);\n    const router = createRouterFunction(routes, wrappedOpts);\n    const basename = opts?.basename;\n\n    if (router.state.historyAction === 'POP' && activeRootSpan) {\n      updatePageloadTransaction({\n        activeRootSpan,\n        location: router.state.location,\n        routes,\n        basename,\n        allRoutes: Array.from(allRoutes),\n      });\n    }\n\n    setupRouterSubscription(router, routes, version, basename, activeRootSpan);\n\n    return router;\n  };\n}\n\n/**\n * Creates a wrapCreateMemoryRouter function that can be used with all React Router v6 compatible versions.\n */\nexport function createV6CompatibleWrapCreateMemoryRouter<\n  TState extends RouterState = RouterState,\n  TRouter extends Router<TState> = Router<TState>,\n>(\n  createRouterFunction: CreateRouterFunction<TState, TRouter>,\n  version: V6CompatibleVersion,\n): CreateRouterFunction<TState, TRouter> {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(\n        `reactRouterV${version}Instrumentation was unable to wrap the \\`createMemoryRouter\\` function because of one or more missing parameters.`,\n      );\n\n    return createRouterFunction;\n  }\n\n  return function (\n    routes: RouteObject[],\n    opts?: Record<string, unknown> & {\n      basename?: string;\n      initialEntries?: (string | { pathname: string })[];\n      initialIndex?: number;\n    },\n  ): TRouter {\n    addRoutesToAllRoutes(routes);\n\n    if (_enableAsyncRouteHandlers) {\n      for (const route of routes) {\n        checkRouteForAsyncHandler(route, processResolvedRoutes);\n      }\n    }\n\n    // Capture the active span BEFORE creating the router (same as browser router)\n    const memoryActiveRootSpanEarly = getActiveRootSpan();\n\n    // If patchRoutesOnNavigation is provided and we have an active span,\n    // mark the span as having potential lazy routes and create a deferred promise.\n    const hasPatchRoutesOnNavigation =\n      opts && 'patchRoutesOnNavigation' in opts && typeof opts.patchRoutesOnNavigation === 'function';\n    if (hasPatchRoutesOnNavigation && memoryActiveRootSpanEarly) {\n      addNonEnumerableProperty(\n        memoryActiveRootSpanEarly as unknown as Record<string, boolean>,\n        '__sentry_may_have_lazy_routes__',\n        true,\n      );\n      createDeferredLazyRoutePromise(memoryActiveRootSpanEarly);\n    }\n\n    const wrappedOpts = wrapPatchRoutesOnNavigation(opts, true, memoryActiveRootSpanEarly);\n\n    const router = createRouterFunction(routes, wrappedOpts);\n    const basename = opts?.basename;\n\n    let initialEntry = undefined;\n\n    const initialEntries = opts?.initialEntries;\n    const initialIndex = opts?.initialIndex;\n\n    const hasOnlyOneInitialEntry = initialEntries && initialEntries.length === 1;\n    const hasIndexedEntry = initialIndex !== undefined && initialEntries && initialEntries[initialIndex];\n\n    initialEntry = hasOnlyOneInitialEntry\n      ? initialEntries[0]\n      : hasIndexedEntry\n        ? initialEntries[initialIndex]\n        : undefined;\n\n    const location = initialEntry\n      ? typeof initialEntry === 'string'\n        ? { pathname: initialEntry }\n        : initialEntry\n      : router.state.location;\n\n    const memoryActiveRootSpan = getActiveRootSpan();\n\n    if (router.state.historyAction === 'POP' && memoryActiveRootSpan) {\n      updatePageloadTransaction({\n        activeRootSpan: memoryActiveRootSpan,\n        location,\n        routes,\n        basename,\n        allRoutes: Array.from(allRoutes),\n      });\n    }\n\n    setupRouterSubscription(router, routes, version, basename, memoryActiveRootSpan);\n\n    return router;\n  };\n}\n\n/**\n * Creates a browser tracing integration that can be used with all React Router v6 compatible versions.\n */\nexport function createReactRouterV6CompatibleTracingIntegration(\n  options: Parameters<typeof browserTracingIntegration>[0] & ReactRouterOptions,\n  version: V6CompatibleVersion,\n): Integration {\n  const integration = browserTracingIntegration({ ...options, instrumentPageLoad: false, instrumentNavigation: false });\n\n  const {\n    useEffect,\n    useLocation,\n    useNavigationType,\n    createRoutesFromChildren,\n    matchRoutes,\n    stripBasename,\n    enableAsyncRouteHandlers = false,\n    instrumentPageLoad = true,\n    instrumentNavigation = true,\n    lazyRouteTimeout,\n  } = options;\n\n  return {\n    ...integration,\n    setup(client) {\n      integration.setup(client);\n\n      const finalTimeout = options.finalTimeout ?? 30000;\n      const defaultMaxWait = (options.idleTimeout ?? 1000) * 3;\n      const configuredMaxWait = lazyRouteTimeout ?? defaultMaxWait;\n\n      // Cap Infinity at finalTimeout to prevent indefinite hangs\n      if (configuredMaxWait === Infinity) {\n        _lazyRouteTimeout = finalTimeout;\n        DEBUG_BUILD &&\n          debug.log(\n            '[React Router] lazyRouteTimeout set to Infinity, capping at finalTimeout:',\n            finalTimeout,\n            'ms to prevent indefinite hangs',\n          );\n      } else if (Number.isNaN(configuredMaxWait)) {\n        DEBUG_BUILD &&\n          debug.warn('[React Router] lazyRouteTimeout must be a number, falling back to default:', defaultMaxWait);\n        _lazyRouteTimeout = defaultMaxWait;\n      } else if (configuredMaxWait < 0) {\n        DEBUG_BUILD &&\n          debug.warn(\n            '[React Router] lazyRouteTimeout must be non-negative or Infinity, got:',\n            configuredMaxWait,\n            'falling back to:',\n            defaultMaxWait,\n          );\n        _lazyRouteTimeout = defaultMaxWait;\n      } else {\n        _lazyRouteTimeout = configuredMaxWait;\n      }\n\n      _useEffect = useEffect;\n      _useLocation = useLocation;\n      _useNavigationType = useNavigationType;\n      _matchRoutes = matchRoutes;\n      _createRoutesFromChildren = createRoutesFromChildren;\n      _enableAsyncRouteHandlers = enableAsyncRouteHandlers;\n\n      // Initialize the router utils with the required dependencies\n      initializeRouterUtils(matchRoutes, stripBasename || false);\n    },\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n\n      const initPathName = WINDOW.location?.pathname;\n      if (instrumentPageLoad && initPathName) {\n        startBrowserTracingPageLoadSpan(client, {\n          name: initPathName,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.pageload.react.reactrouter_v${version}`,\n          },\n        });\n      }\n\n      if (instrumentNavigation) {\n        CLIENTS_WITH_INSTRUMENT_NAVIGATION.add(client);\n      }\n    },\n  };\n}\n\nexport function createV6CompatibleWrapUseRoutes(origUseRoutes: UseRoutes, version: V6CompatibleVersion): UseRoutes {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(\n        'reactRouterV6Instrumentation was unable to wrap `useRoutes` because of one or more missing parameters.',\n      );\n\n    return origUseRoutes;\n  }\n\n  const SentryRoutes: React.FC<{\n    children?: React.ReactNode;\n    routes: RouteObject[];\n    locationArg?: Partial<Location> | string;\n  }> = (props: { children?: React.ReactNode; routes: RouteObject[]; locationArg?: Partial<Location> | string }) => {\n    const isMountRenderPass = React.useRef(true);\n    const { routes, locationArg } = props;\n\n    const Routes = origUseRoutes(routes, locationArg);\n\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n\n    // A value with stable identity to either pick `locationArg` if available or `location` if not\n    const stableLocationParam =\n      typeof locationArg === 'string' || locationArg?.pathname ? (locationArg as { pathname: string }) : location;\n\n    _useEffect(() => {\n      const normalizedLocation =\n        typeof stableLocationParam === 'string' ? { pathname: stableLocationParam } : stableLocationParam;\n\n      if (isMountRenderPass.current) {\n        addRoutesToAllRoutes(routes);\n\n        updatePageloadTransaction({\n          activeRootSpan: getActiveRootSpan(),\n          location: normalizedLocation,\n          routes,\n          allRoutes: Array.from(allRoutes),\n        });\n        isMountRenderPass.current = false;\n      } else {\n        // Note: Component-based routes don't support lazy route tracking via lazyRouteTimeout\n        // because React.lazy() loads happen at the component level, not the router level.\n        // Use createBrowserRouter with patchRoutesOnNavigation for lazy route tracking.\n        handleNavigation({\n          location: normalizedLocation,\n          routes,\n          navigationType,\n          version,\n          allRoutes: Array.from(allRoutes),\n        });\n      }\n    }, [navigationType, stableLocationParam]);\n\n    return Routes;\n  };\n\n  // eslint-disable-next-line react/display-name\n  return (routes: RouteObject[], locationArg?: Partial<Location> | string): React.ReactElement | null => {\n    return <SentryRoutes routes={routes} locationArg={locationArg} />;\n  };\n}\nfunction wrapPatchRoutesOnNavigation(\n  opts: Record<string, unknown> | undefined,\n  isMemoryRouter = false,\n  capturedSpan?: Span,\n): Record<string, unknown> {\n  if (!opts || !('patchRoutesOnNavigation' in opts) || typeof opts.patchRoutesOnNavigation !== 'function') {\n    return opts || {};\n  }\n\n  const originalPatchRoutes = opts.patchRoutesOnNavigation;\n  return {\n    ...opts,\n    patchRoutesOnNavigation: async (args: unknown) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n      const targetPath = (args as any)?.path;\n\n      // Use current active span if available, otherwise fall back to captured span (from router creation time).\n      // This ensures navigation spans use their own span (not the stale pageload span), while still\n      // supporting pageload spans that may have ended before patchRoutesOnNavigation is called.\n      const activeRootSpan = getActiveRootSpan() ?? capturedSpan;\n\n      if (!isMemoryRouter) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        const originalPatch = (args as any)?.patch;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        const matches = (args as any)?.matches as Array<{ route: RouteObject }> | undefined;\n        if (originalPatch) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n          (args as any).patch = (routeId: string, children: RouteObject[]) => {\n            addRoutesToAllRoutes(children);\n\n            // Find the parent route from matches and attach children to it in allRoutes.\n            // React Router's patch attaches children to its internal route copies, but we need\n            // to update the route objects in our allRoutes Set for proper route matching.\n            if (matches && matches.length > 0) {\n              const leafMatch = matches[matches.length - 1];\n              const leafRoute = leafMatch?.route;\n              if (leafRoute) {\n                // Find the matching route in allRoutes by id, reference, or path\n                const matchingRoute = Array.from(allRoutes).find(route => {\n                  const idMatches = route.id !== undefined && route.id === routeId;\n                  const referenceMatches = route === leafRoute;\n                  const pathMatches =\n                    route.path !== undefined && leafRoute.path !== undefined && route.path === leafRoute.path;\n\n                  return idMatches || referenceMatches || pathMatches;\n                });\n\n                if (matchingRoute) {\n                  addResolvedRoutesToParent(children, matchingRoute);\n                }\n              }\n            }\n\n            // Use the captured activeRootSpan instead of getActiveRootSpan() to avoid race conditions\n            // where user navigates away during lazy route loading and we'd update the wrong span\n            const spanJson = activeRootSpan ? spanToJSON(activeRootSpan) : undefined;\n            // Only update if we have a valid targetPath (patchRoutesOnNavigation can be called without path),\n            // the captured span exists, hasn't ended, and is a navigation span\n            if (\n              targetPath &&\n              activeRootSpan &&\n              spanJson &&\n              !spanJson.timestamp && // Span hasn't ended yet\n              spanJson.op === 'navigation'\n            ) {\n              updateNavigationSpan(\n                activeRootSpan,\n                { pathname: targetPath, search: '', hash: '', state: null, key: 'default' },\n                Array.from(allRoutes),\n                true,\n                _matchRoutes,\n              );\n            }\n            return originalPatch(routeId, children);\n          };\n        }\n      }\n\n      const lazyLoadPromise = (async () => {\n        // Set context so async handlers can access correct targetPath and span\n        const contextToken = setNavigationContext(targetPath, activeRootSpan);\n        let result;\n        try {\n          result = await originalPatchRoutes(args);\n        } finally {\n          clearNavigationContext(contextToken);\n          // Resolve the deferred promise now that patchRoutesOnNavigation has completed.\n          // This ensures patchedEnd has waited long enough for the lazy routes to load.\n          if (activeRootSpan) {\n            resolveDeferredLazyRoutePromise(activeRootSpan);\n          }\n        }\n\n        // Use the captured activeRootSpan instead of getActiveRootSpan() to avoid race conditions\n        // where user navigates away during lazy route loading and we'd update the wrong span\n        const spanJson = activeRootSpan ? spanToJSON(activeRootSpan) : undefined;\n        if (\n          activeRootSpan &&\n          spanJson &&\n          !spanJson.timestamp && // Span hasn't ended yet\n          spanJson.op === 'navigation'\n        ) {\n          // Use targetPath consistently - don't fall back to WINDOW.location which may have changed\n          // if the user navigated away during async loading\n          const pathname = targetPath;\n\n          if (pathname) {\n            updateNavigationSpan(\n              activeRootSpan,\n              { pathname, search: '', hash: '', state: null, key: 'default' },\n              Array.from(allRoutes),\n              false,\n              _matchRoutes,\n            );\n          }\n        }\n\n        return result;\n      })();\n\n      if (activeRootSpan) {\n        trackLazyRouteLoad(activeRootSpan, lazyLoadPromise);\n      }\n\n      return lazyLoadPromise;\n    },\n  };\n}\n\n// eslint-disable-next-line complexity\nexport function handleNavigation(opts: {\n  location: Location;\n  routes: RouteObject[];\n  navigationType: Action;\n  version: V6CompatibleVersion;\n  matches?: AgnosticDataRouteMatch;\n  basename?: string;\n  allRoutes?: RouteObject[];\n}): void {\n  const { location, routes, navigationType, version, matches, basename, allRoutes } = opts;\n  const branches = Array.isArray(matches) ? matches : _matchRoutes(allRoutes || routes, location, basename);\n\n  const client = getClient();\n  if (!client || !CLIENTS_WITH_INSTRUMENT_NAVIGATION.has(client)) {\n    return;\n  }\n\n  const activeRootSpan = getActiveRootSpan();\n  if (activeRootSpan && spanToJSON(activeRootSpan).op === 'pageload' && navigationType === 'POP') {\n    return;\n  }\n\n  if ((navigationType === 'PUSH' || navigationType === 'POP') && branches) {\n    const [name, source] = resolveRouteNameAndSource(\n      location,\n      allRoutes || routes,\n      allRoutes || routes,\n      branches as RouteMatch[],\n      basename,\n    );\n\n    const locationKey = computeLocationKey(location);\n    const trackedNav = activeNavigationSpans.get(client);\n\n    // Determine if this navigation should be skipped as a duplicate\n    const trackedSpanHasEnded =\n      trackedNav && !trackedNav.isPlaceholder ? !!spanToJSON(trackedNav.span).timestamp : false;\n    const { skip, shouldUpdate } = shouldSkipNavigation(trackedNav, locationKey, name, trackedSpanHasEnded);\n\n    if (skip) {\n      if (shouldUpdate && trackedNav) {\n        const oldName = trackedNav.routeName;\n\n        if (trackedNav.isPlaceholder) {\n          // Update placeholder's route name - the real span will be created with this name\n          trackedNav.routeName = name;\n          DEBUG_BUILD &&\n            debug.log(\n              `[Tracing] Updated placeholder navigation name from \"${oldName}\" to \"${name}\" (will apply to real span)`,\n            );\n        } else {\n          // Update existing real span from wildcard to parameterized route name\n          trackedNav.span.updateName(name);\n          trackedNav.span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source as 'route' | 'url' | 'custom');\n          addNonEnumerableProperty(\n            trackedNav.span as { __sentry_navigation_name_set__?: boolean },\n            '__sentry_navigation_name_set__',\n            true,\n          );\n          trackedNav.routeName = name;\n          DEBUG_BUILD && debug.log(`[Tracing] Updated navigation span name from \"${oldName}\" to \"${name}\"`);\n        }\n      } else {\n        DEBUG_BUILD && debug.log(`[Tracing] Skipping duplicate navigation for location: ${locationKey}`);\n      }\n      return;\n    }\n\n    // Create new navigation span (first navigation or legitimate new navigation)\n    // Reserve the spot in the map first to prevent race conditions\n    // Mark as placeholder to prevent concurrent handleNavigation calls from creating duplicates\n    const placeholderSpan = { end: () => {} } as unknown as Span;\n    const placeholderEntry = {\n      span: placeholderSpan,\n      routeName: name,\n      pathname: location.pathname,\n      locationKey,\n      isPlaceholder: true as const,\n    };\n    activeNavigationSpans.set(client, placeholderEntry);\n\n    let navigationSpan: Span | undefined;\n    try {\n      navigationSpan = startBrowserTracingNavigationSpan(client, {\n        name: placeholderEntry.routeName, // Use placeholder's routeName in case it was updated\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.navigation.react.reactrouter_v${version}`,\n        },\n      });\n    } catch (e) {\n      // If span creation fails, remove the placeholder so we don't block future navigations\n      activeNavigationSpans.delete(client);\n      throw e;\n    }\n\n    if (navigationSpan) {\n      // Update the map with the real span (isPlaceholder omitted, defaults to false)\n      activeNavigationSpans.set(client, {\n        span: navigationSpan,\n        routeName: placeholderEntry.routeName, // Use the (potentially updated) placeholder routeName\n        pathname: location.pathname,\n        locationKey,\n      });\n      patchSpanEnd(navigationSpan, location, routes, basename, 'navigation');\n    } else {\n      // If no span was created, remove the placeholder\n      activeNavigationSpans.delete(client);\n    }\n  }\n}\n\n/* Only exported for testing purposes */\nexport function addRoutesToAllRoutes(routes: RouteObject[]): void {\n  routes.forEach(route => {\n    const extractedChildRoutes = getChildRoutesRecursively(route);\n\n    extractedChildRoutes.forEach(r => {\n      allRoutes.add(r);\n    });\n  });\n}\n\nfunction getChildRoutesRecursively(route: RouteObject, allRoutes: Set<RouteObject> = new Set()): Set<RouteObject> {\n  if (!allRoutes.has(route)) {\n    allRoutes.add(route);\n\n    if (route.children && !route.index) {\n      route.children.forEach(child => {\n        const childRoutes = getChildRoutesRecursively(child, allRoutes);\n\n        childRoutes.forEach(r => {\n          allRoutes.add(r);\n        });\n      });\n    }\n  }\n\n  return allRoutes;\n}\n\nfunction updatePageloadTransaction({\n  activeRootSpan,\n  location,\n  routes,\n  matches,\n  basename,\n  allRoutes,\n}: {\n  activeRootSpan: Span | undefined;\n  location: Location;\n  routes: RouteObject[];\n  matches?: AgnosticDataRouteMatch;\n  basename?: string;\n  allRoutes?: RouteObject[];\n}): void {\n  const branches = Array.isArray(matches)\n    ? matches\n    : (_matchRoutes(allRoutes || routes, location, basename) as unknown as RouteMatch[]);\n\n  if (branches) {\n    const [name, source] = resolveRouteNameAndSource(\n      location,\n      allRoutes || routes,\n      allRoutes || routes,\n      branches,\n      basename,\n    );\n\n    getCurrentScope().setTransactionName(name || '/');\n\n    if (activeRootSpan) {\n      activeRootSpan.updateName(name);\n      activeRootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n\n      // Patch span.end() to ensure we update the name one last time before the span is sent\n      patchSpanEnd(activeRootSpan, location, routes, basename, 'pageload');\n    }\n  } else if (activeRootSpan) {\n    // Even if branches is null (can happen when lazy routes haven't loaded yet),\n    // we still need to patch span.end() so that when lazy routes load and the span ends,\n    // we can update the transaction name correctly.\n    patchSpanEnd(activeRootSpan, location, routes, basename, 'pageload');\n  }\n}\n\n/**\n * Determines if a span name should be updated during wildcard route resolution.\n *\n * Update conditions (in priority order):\n * 1. No current name + allowNoCurrentName: true → always update (pageload spans)\n * 2. Current name has wildcard + new is route without wildcard → upgrade (e.g., \"/users/*\" → \"/users/:id\")\n * 3. Current source is not 'route' + new source is 'route' → upgrade (e.g., URL → parameterized route)\n *\n * @param currentName - The current span name (may be undefined)\n * @param currentSource - The current span source ('route', 'url', or undefined)\n * @param newName - The proposed new span name\n * @param newSource - The proposed new span source\n * @param allowNoCurrentName - If true, allow updates when there's no current name (for pageload spans)\n * @returns true if the span name should be updated\n */\nfunction shouldUpdateWildcardSpanName(\n  currentName: string | undefined,\n  currentSource: string | undefined,\n  newName: string,\n  newSource: string,\n  allowNoCurrentName = false,\n): boolean {\n  if (!newName) {\n    return false;\n  }\n\n  if (!currentName && allowNoCurrentName) {\n    return true;\n  }\n\n  const hasWildcard = currentName && transactionNameHasWildcard(currentName);\n\n  if (hasWildcard && newSource === 'route' && !transactionNameHasWildcard(newName)) {\n    return true;\n  }\n\n  if (currentSource !== 'route' && newSource === 'route') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction tryUpdateSpanNameBeforeEnd(\n  span: Span,\n  spanJson: ReturnType<typeof spanToJSON>,\n  currentName: string | undefined,\n  location: Location,\n  routes: RouteObject[],\n  basename: string | undefined,\n  spanType: 'pageload' | 'navigation',\n  allRoutes: Set<RouteObject>,\n): void {\n  try {\n    const currentSource = spanJson.data?.[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    if (currentSource === 'route' && currentName && !transactionNameHasWildcard(currentName)) {\n      return;\n    }\n\n    const currentAllRoutes = Array.from(allRoutes);\n    const routesToUse = currentAllRoutes.length > 0 ? currentAllRoutes : routes;\n    const branches = _matchRoutes(routesToUse, location, basename) as unknown as RouteMatch[];\n\n    if (!branches) {\n      return;\n    }\n\n    const [name, source] = resolveRouteNameAndSource(location, routesToUse, routesToUse, branches, basename);\n\n    const isImprovement = shouldUpdateWildcardSpanName(currentName, currentSource, name, source, true);\n    const spanNotEnded = spanType === 'pageload' || !spanJson.timestamp;\n\n    if (isImprovement && spanNotEnded) {\n      span.updateName(name);\n      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n    }\n  } catch (error) {\n    DEBUG_BUILD && debug.warn(`Error updating span details before ending: ${error}`);\n  }\n}\n\n/**\n * Patches the span.end() method to update the transaction name one last time before the span is sent.\n * This handles cases where the span is cancelled early (e.g., document.hidden) before lazy routes have finished loading.\n */\nfunction patchSpanEnd(\n  span: Span,\n  location: Location,\n  routes: RouteObject[],\n  basename: string | undefined,\n  spanType: 'pageload' | 'navigation',\n): void {\n  const patchedPropertyName = `__sentry_${spanType}_end_patched__` as const;\n  const hasEndBeenPatched = (span as unknown as Record<string, boolean | undefined>)?.[patchedPropertyName];\n\n  if (hasEndBeenPatched || !span.end) {\n    return;\n  }\n\n  // Uses global allRoutes to access lazy-loaded routes added after this function was called.\n\n  const originalEnd = span.end.bind(span);\n  let endCalled = false;\n\n  span.end = function patchedEnd(...args) {\n    if (endCalled) {\n      return;\n    }\n    endCalled = true;\n\n    // Capture timestamp immediately to avoid delay from async operations\n    // If no timestamp was provided, capture the current time now\n    const endTimestamp = args.length > 0 ? args[0] : Date.now() / 1000;\n\n    const spanJson = spanToJSON(span);\n    const currentName = spanJson.description;\n    const currentSource = spanJson.data?.[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    // Helper to clean up activeNavigationSpans after span ends\n    const cleanupNavigationSpan = (): void => {\n      const client = getClient();\n      if (client && spanType === 'navigation') {\n        const trackedNav = activeNavigationSpans.get(client);\n        if (trackedNav && trackedNav.span === span) {\n          activeNavigationSpans.delete(client);\n        }\n      }\n    };\n\n    const pendingPromises = pendingLazyRouteLoads.get(span);\n    const mayHaveLazyRoutes = (span as unknown as Record<string, boolean>).__sentry_may_have_lazy_routes__;\n\n    // Wait for lazy routes if:\n    // 1. (There are pending promises OR the span was marked as potentially having lazy routes) AND\n    // 2. Current name exists AND\n    // 3. Either the name has a wildcard OR the source is not 'route' (URL-based names)\n    const hasPendingOrMayHaveLazyRoutes = (pendingPromises && pendingPromises.size > 0) || mayHaveLazyRoutes;\n    const shouldWaitForLazyRoutes =\n      hasPendingOrMayHaveLazyRoutes &&\n      currentName &&\n      (transactionNameHasWildcard(currentName) || currentSource !== 'route');\n\n    if (shouldWaitForLazyRoutes) {\n      if (_lazyRouteTimeout === 0) {\n        tryUpdateSpanNameBeforeEnd(span, spanJson, currentName, location, routes, basename, spanType, allRoutes);\n        cleanupNavigationSpan();\n        originalEnd(endTimestamp);\n        return;\n      }\n\n      // If we have pending promises, wait for them. Otherwise, just wait for the timeout.\n      // This handles the case where we know lazy routes might load but patchRoutesOnNavigation\n      // hasn't been called yet.\n      const timeoutPromise = new Promise<void>(r => setTimeout(r, _lazyRouteTimeout));\n      let waitPromise: Promise<void>;\n\n      if (pendingPromises && pendingPromises.size > 0) {\n        const allSettled = Promise.allSettled(pendingPromises).then(() => {});\n        waitPromise = _lazyRouteTimeout === Infinity ? allSettled : Promise.race([allSettled, timeoutPromise]);\n      } else {\n        // No pending promises yet, but we know lazy routes might load\n        // Wait for the timeout to give React Router time to call patchRoutesOnNavigation\n        waitPromise = timeoutPromise;\n      }\n\n      waitPromise\n        .then(() => {\n          const updatedSpanJson = spanToJSON(span);\n          tryUpdateSpanNameBeforeEnd(\n            span,\n            updatedSpanJson,\n            updatedSpanJson.description,\n            location,\n            routes,\n            basename,\n            spanType,\n            allRoutes,\n          );\n          cleanupNavigationSpan();\n          originalEnd(endTimestamp);\n        })\n        .catch(() => {\n          cleanupNavigationSpan();\n          originalEnd(endTimestamp);\n        });\n      return;\n    }\n\n    tryUpdateSpanNameBeforeEnd(span, spanJson, currentName, location, routes, basename, spanType, allRoutes);\n    cleanupNavigationSpan();\n    originalEnd(endTimestamp);\n  };\n\n  addNonEnumerableProperty(span as unknown as Record<string, boolean>, patchedPropertyName, true);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function createV6CompatibleWithSentryReactRouterRouting<P extends Record<string, any>, R extends React.FC<P>>(\n  Routes: R,\n  version: V6CompatibleVersion,\n): R {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_createRoutesFromChildren || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(`reactRouterV6Instrumentation was unable to wrap Routes because of one or more missing parameters.\n      useEffect: ${_useEffect}. useLocation: ${_useLocation}. useNavigationType: ${_useNavigationType}.\n      createRoutesFromChildren: ${_createRoutesFromChildren}. matchRoutes: ${_matchRoutes}.`);\n\n    return Routes;\n  }\n\n  const SentryRoutes: React.FC<P> = (props: P) => {\n    const isMountRenderPass = React.useRef(true);\n\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n\n    _useEffect(\n      () => {\n        const routes = _createRoutesFromChildren(props.children) as RouteObject[];\n\n        if (isMountRenderPass.current) {\n          addRoutesToAllRoutes(routes);\n\n          updatePageloadTransaction({\n            activeRootSpan: getActiveRootSpan(),\n            location,\n            routes,\n            allRoutes: Array.from(allRoutes),\n          });\n          isMountRenderPass.current = false;\n        } else {\n          // Note: Component-based routes don't support lazy route tracking via lazyRouteTimeout\n          // because React.lazy() loads happen at the component level, not the router level.\n          // Use createBrowserRouter with patchRoutesOnNavigation for lazy route tracking.\n          handleNavigation({ location, routes, navigationType, version, allRoutes: Array.from(allRoutes) });\n        }\n      },\n      // Re-run only on location/navigation changes, not children changes\n      [location, navigationType],\n    );\n\n    // @ts-expect-error Setting more specific React Component typing for `R` generic above\n    // will break advanced type inference done by react router params\n    return <Routes {...props} />;\n  };\n\n  hoistNonReactStatics(SentryRoutes, Routes);\n\n  // @ts-expect-error Setting more specific React Component typing for `R` generic above\n  // will break advanced type inference done by react router params\n  return SentryRoutes;\n}\n"],"names":["WINDOW","transactionNameHasWildcard","checkRouteForAsyncHandler","getActiveRootSpan","spanToJSON","DEBUG_BUILD","debug","resolveRouteNameAndSource","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","addNonEnumerableProperty","browserTracingIntegration","initializeRouterUtils","startBrowserTracingPageLoadSpan","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","setNavigationContext","clearNavigationContext","getClient","startBrowserTracingNavigationSpan","getCurrentScope","hoistNonReactStatics"],"mappings":"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"}